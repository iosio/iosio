{"version":3,"file":"Component.js","sources":["../../vdom/src/index.js","../src/styles.js","../src/Component.js","../src/state.js","../src/events.js","../src/renderer.js"],"sourcesContent":["const RECYCLED_NODE = 1,\n    TEXT_NODE = 3,\n    EMPTY_OBJ = {},\n    EMPTY_ARR = [],\n    map = EMPTY_ARR.map,\n    IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i,\n    isArray = Array.isArray,\n    d = document,\n\n    eventProxy = function (e) {\n        return this.__ev[e.type](e);\n    },\n\n    setStyle = (style, key, value) => {\n        if (key[0] === '-') style.setProperty(key, value);\n        else style[key] = typeof value === 'number'\n        && IS_NON_DIMENSIONAL.test(key) === false ? value + 'px' : value == null ? '' : value;\n    },\n    // preact based setProperty\n    setProperty = (dom, name, value, oldValue, isSvg, _style, _newHTML) => {\n        if (isSvg) {\n            if (name === 'className') name = 'class';\n        } else if (name === 'class') name = 'className';\n        if (name === 'key' || name === 'children') {\n        } else if (name === 'style') {\n            _style = dom.style;\n            if (typeof value === 'string') _style.cssText = value;\n            else {\n                if (typeof oldValue === 'string') (_style.cssText = '', oldValue = null);\n                if (oldValue) for (let i in oldValue) if (!(value && i in value)) setStyle(_style, i, '');\n                if (value) for (let i in value) if (!oldValue || value[i] !== oldValue[i]) setStyle(_style, i, value[i]);\n            }\n        } else if (name[0] === 'o' && name[1] === 'n') {\n            let useCapture = name !== (name = name.replace(/Capture$/, '')),\n                nameLower = name.toLowerCase();\n            name = (nameLower in dom ? nameLower : name).slice(2);\n            if (value) {\n                if (!oldValue) dom.addEventListener(name, eventProxy, useCapture);\n                (dom.__ev || (dom.__ev = {}))[name] = value;\n            } else dom.removeEventListener(name, eventProxy, useCapture);\n        } else if (name === 'dangerouslySetInnerHTML') {\n            if (value || oldValue) {\n                if (!value || !oldValue || value.__html != oldValue.__html) {\n                    dom.innerHTML = (value && value.__html) || '';\n                }\n                value && console.log('setting dangerouslySetInnerHTML');\n                if (value) return true\n            }\n        } else if (!(['list', 'tagName', 'form', 'type', 'size'].includes(name)) && !isSvg && name in dom) {\n            dom[name] = value == null ? '' : value;\n        } else if (typeof value !== 'function') {\n            if (name !== (name = name.replace(/^xlink:?/, ''))) {\n                if (value == null || value === false) {\n                    dom.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());\n                } else dom.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);\n            } else if (value == null || (value === false && !/^ar/.test(name))) dom.removeAttribute(name);\n            else dom.setAttribute(name, value);\n        }\n    },\n\n    diffProps = (dom, newProps, oldProps, isSvg, _newHTML) => {\n        let i;\n        for (i in oldProps) if (!(i in newProps)) {\n            if (setProperty(dom, i, null, oldProps[i], isSvg)) _newHTML = true;\n        }\n        for (i in newProps) if (i !== 'value' && i !== 'checked' && oldProps[i] !== newProps[i]) {\n            if (setProperty(dom, i, newProps[i], oldProps[i], isSvg)) _newHTML = true;\n        }\n        return _newHTML\n    },\n\n    getKey = (vnode) => vnode == null ? null : vnode.key,\n\n    patchNode = (parent, node, oldVNode, newVNode, isSvg) => {\n        if (oldVNode === newVNode) {\n        } else if (\n            oldVNode != null &&\n            oldVNode.type === TEXT_NODE &&\n            newVNode.type === TEXT_NODE\n        ) {\n            if (oldVNode.name !== newVNode.name) node.nodeValue = newVNode.name\n        } else if (oldVNode == null || oldVNode.name !== newVNode.name) {\n            node = parent.insertBefore(createNode(newVNode, isSvg), node)\n            if (oldVNode != null) {\n                parent.removeChild(oldVNode.node)\n            }\n        } else {\n            let tmpVKid, oldVKid,\n                oldKey, newKey,\n                oldVProps = oldVNode.props,\n                newVProps = newVNode.props,\n                oldVKids = oldVNode.children,\n                newVKids = newVNode.children,\n                oldHead = 0,\n                newHead = 0,\n                oldTail = oldVKids.length - 1,\n                newTail = newVKids.length - 1;\n\n            isSvg = isSvg || newVNode.name === \"svg\"\n\n            if (diffProps(node, newVProps, oldVProps, isSvg)) {\n                return (newVNode.node = node);\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldHead])) == null ||\n                    oldKey !== getKey(newVKids[newHead])\n                ) {\n                    break\n                }\n                patchNode(\n                    node,\n                    oldVKids[oldHead].node,\n                    oldVKids[oldHead++],\n                    newVKids[newHead++],\n                    isSvg\n                )\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldTail])) == null ||\n                    oldKey !== getKey(newVKids[newTail])\n                ) {\n                    break\n                }\n\n                patchNode(\n                    node,\n                    oldVKids[oldTail].node,\n                    oldVKids[oldTail--],\n                    newVKids[newTail--],\n                    isSvg\n                )\n            }\n\n            if (oldHead > oldTail) {\n                while (newHead <= newTail) {\n                    node.insertBefore(\n                        createNode(newVKids[newHead++], isSvg),\n                        (oldVKid = oldVKids[oldHead]) && oldVKid.node\n                    )\n                }\n            } else if (newHead > newTail) {\n                while (oldHead <= oldTail) {\n                    node.removeChild(oldVKids[oldHead++].node)\n                }\n            } else {\n                for (var i = oldHead, keyed = {}, newKeyed = {}; i <= oldTail; i++) {\n                    if ((oldKey = oldVKids[i].key) != null) {\n                        keyed[oldKey] = oldVKids[i]\n                    }\n                }\n\n                while (newHead <= newTail) {\n                    oldKey = getKey((oldVKid = oldVKids[oldHead]))\n                    newKey = getKey(newVKids[newHead])\n\n                    if (\n                        newKeyed[oldKey] ||\n                        (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))\n                    ) {\n                        if (oldKey == null) {\n                            node.removeChild(oldVKid.node)\n                        }\n                        oldHead++\n                        continue\n                    }\n\n                    if (newKey == null || oldVNode.type === RECYCLED_NODE) {\n                        if (oldKey == null) {\n                            patchNode(\n                                node,\n                                oldVKid && oldVKid.node,\n                                oldVKid,\n                                newVKids[newHead],\n                                isSvg\n                            )\n                            newHead++\n                        }\n                        oldHead++\n                    } else {\n                        if (oldKey === newKey) {\n                            patchNode(node, oldVKid.node, oldVKid, newVKids[newHead], isSvg)\n                            newKeyed[newKey] = true\n                            oldHead++\n                        } else {\n                            if ((tmpVKid = keyed[newKey]) != null) {\n                                patchNode(\n                                    node,\n                                    node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),\n                                    tmpVKid,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                                newKeyed[newKey] = true\n                            } else {\n                                patchNode(\n                                    node,\n                                    oldVKid && oldVKid.node,\n                                    null,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                            }\n                        }\n                        newHead++\n                    }\n                }\n\n                while (oldHead <= oldTail) {\n                    if (getKey((oldVKid = oldVKids[oldHead++])) == null) {\n                        node.removeChild(oldVKid.node)\n                    }\n                }\n\n                for (var i in keyed) {\n                    if (newKeyed[i] == null) {\n                        node.removeChild(keyed[i].node)\n                    }\n                }\n            }\n        }\n\n        return (newVNode.node = node)\n    },\n\n    createNode = (vnode, isSvg) => {\n        var node = vnode.type === TEXT_NODE\n            ? d.createTextNode(vnode.name)\n            : (isSvg = isSvg || vnode.name === \"svg\")\n                ? d.createElementNS(\"http://www.w3.org/2000/svg\", vnode.name)\n                : d.createElement(vnode.name);\n        diffProps(node, vnode.props, {}, isSvg);\n        for (var i = 0, len = vnode.children.length; i < len; i++) {\n            node.appendChild(createNode(vnode.children[i], isSvg))\n        }\n        return (vnode.node = node)\n    },\n\n    createVNode = (name, props, children, node, key, type) => ({\n        name: name,\n        props: props,\n        children: children,\n        node: node,\n        type: type,\n        key: key,\n    }),\n\n    createTextVNode = (value, node) => createVNode(value, EMPTY_OBJ, EMPTY_ARR, node, null, TEXT_NODE),\n\n    recycleNode = (node, parent) => {\n        return node.nodeType === TEXT_NODE\n            ? createTextVNode(node.nodeValue, node)\n            : createVNode(\n                node.nodeName.toLowerCase(),\n                EMPTY_OBJ,\n                map.call(node.childNodes, recycleNode),\n                node,\n                null,\n                RECYCLED_NODE\n            )\n    },\n    Fragment = (props) => props.children,\n\n    render = (node, vdom, options) => {\n        let oldVDom = node.vdom || recycleNode(node);\n        vdom = createVNode(\n            oldVDom.name,\n            EMPTY_OBJ,\n            [].concat(vdom),\n            oldVDom.node\n        );\n        return ((node = patchNode(\n            node.parentNode,\n            node,\n            oldVDom,\n            vdom\n        )).vdom = vdom), node\n    },\n\n    mount = (node, vdom) => {\n        if (!isArray(vdom)) vdom = [vdom];\n        for (var i = vdom.length; i--;) node.insertBefore(createNode(vdom[i]), node.firstChild)\n    },\n\n    h = function (name, props) {\n        for (var vnode, rest = [], children = [], i = arguments.length; i-- > 2;) rest.push(arguments[i]);\n        if ((props = props == null ? {} : props).children != null) {\n            if (rest.length <= 0) rest.push(props.children);\n            delete props.children;\n        }\n        while (rest.length > 0) {\n            if (isArray((vnode = rest.pop()))) {\n                for (var i = vnode.length; i-- > 0;) rest.push(vnode[i])\n            } else if (vnode === false || vnode === true || vnode == null) {\n            } else children.push(typeof vnode === 'object' ? vnode : createTextVNode(vnode));\n        }\n        return typeof name === 'function'\n            ? (props.children = props.children || children) && name(props)\n            : createVNode(name, props, children, null, props.key)\n    };\nexport {h, render, Fragment, createNode, mount};","export const createStyleTag = (css) => {\n    let style = document.createElement('style');\n    style.appendChild(document.createTextNode(css));\n    return {\n        element: style,\n        update: (css) => style.textContent = css\n    };\n};\n\nexport const getShadowParent = elmnt => {\n    while (elmnt.parentNode && (elmnt = elmnt.parentNode)) if (elmnt instanceof ShadowRoot) return elmnt;\n    return document;\n};\n\nexport const CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE = \"adoptedStyleSheets\" in document;\nexport const DEFAULT_SHADOWROOT_HOST_CSS_RESETS = `:host, *, *::before, *::after {box-sizing: border-box;} `;\n\nconst constructableStyleCache = new Map();\nconst constructableStyleTagFallbackCache = new Map();\n\nexport const adoptStyles = (element, cssString, options = {}) => {\n    const {async, getStringOnFallback, useStyleTag, noDefaultResets} = options;\n\n    cssString = (element.shadowRoot && !noDefaultResets ? DEFAULT_SHADOWROOT_HOST_CSS_RESETS : '')\n        + (cssString || options.cssString || '');\n\n    const signature = element.constructor.tag || element.constructor;\n\n    if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE && !useStyleTag) {\n        let adopter = element.shadowRoot || getShadowParent(element);\n        let constructable = constructableStyleCache.get(signature);\n        if (!constructable) {\n            constructable = new CSSStyleSheet();\n            constructable[async ? 'replace' : 'replaceSync'](cssString);\n            constructableStyleCache.set(signature, constructable);\n        }\n        if (!([].concat(adopter.adoptedStyleSheets).includes(constructable))) {\n            adopter.adoptedStyleSheets = [...adopter.adoptedStyleSheets, constructable];\n        }\n    } else {\n        if (getStringOnFallback) return cssString;\n        let style = constructableStyleTagFallbackCache.get(signature);\n        if (!style) {\n            style = createStyleTag(cssString).element;\n            constructableStyleTagFallbackCache.set(signature, style);\n        }\n        (element.shadowRoot || element).appendChild(style.cloneNode(true));\n    }\n};\n\nexport const styles = (cssString, options = {}) => (self) => {\n    let adopt = () => (self.fallbackCssString = adoptStyles(self, cssString, {getStringOnFallback: self.hasRenderer, ...options}));\n    self.shadowRoot ? adopt() : self.mounted.then(adopt);\n};\n","import {renderer} from \"./renderer\";\nimport {styles as adoptStyles} from \"./styles\";\nimport {state} from \"./state\";\nimport {events} from \"./events\";\n\nexport class Component extends Base{\n    constructor() {\n        super();\n        const {styles} = this.constructor;\n        this.renderer = this.render ? renderer(this.render)(this) : NOOP;\n        styles && adoptStyles(styles)(this);\n        state(this.state)(this);\n        events()(this);\n    }\n\n    initialUpdate() {\n        this.beforeInitialUpdate(...this.getArgs());\n        this.renderer();\n        this.unmount = this.didMount(...this.getArgs()) || NOOP();\n        this.logic[0] && this.logic[0]();\n    }\n\n    subsequentUpdate() {\n        this.renderer();\n        this.didUpdate(...this.getArgs());\n        this.logic[1] && this.logic[1]();\n    }\n\n    beforeInitialUpdate() {\n    }\n\n    didMount() {\n    }\n\n    onStateChange() {\n    }\n\n    didUpdate() {\n    }\n\n}","import {obi} from \"@iosio/obi\";\nimport {isObj} from \"@iosio/util\";\n\nexport const state = obj => (self) =>\n    isObj(obj) && self.unsubs.push((self.state = obi(obj)).$onChange(self.onStateChange));","import {eventListener} from \"@iosio/util\";\nexport const events = () => self => {\n    self.eventListener = (to, ev, cb, opts) =>\n        self.unsubs.push(eventListener(to, ev, cb, opts));\n    self.emit = (event, detail, opts = {}, from = self) =>\n        from.dispatchEvent(new CustomEvent(event, {\n            detail: detail,\n            bubbles: true,\n            composed: true, ...opts\n        }));\n};\nexport {eventListener}","import {render, h, Fragment, createNode, mount} from \"@iosio/vdom\";\n\nexport {render, h, Fragment, createNode, mount};\n\nexport const renderer = render_ => self => () => {\n    let results = render_(self.props, self.state, self);\n    if (!results) return;\n    if (self.fallbackCssString) {\n        let style = h('style', {dangerouslySetInnerHTML: {__html: self.fallbackCssString || ''}});\n        results = Array.isArray(results) ? (results.unshift(style), results) : [style, results];\n    }\n    render(self.shadowRoot || self, results);\n};\n\n"],"names":["RECYCLED_NODE","EMPTY_OBJ","EMPTY_ARR","map","IS_NON_DIMENSIONAL","isArray","Array","d","document","eventProxy","e","__ev","type","setStyle","style","key","value","setProperty","test","dom","name","oldValue","isSvg","_style","_newHTML","cssText","i","useCapture","replace","nameLower","toLowerCase","slice","addEventListener","removeEventListener","__html","innerHTML","console","log","includes","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","diffProps","newProps","oldProps","getKey","vnode","patchNode","parent","node","oldVNode","newVNode","nodeValue","insertBefore","createNode","removeChild","tmpVKid","oldVKid","oldKey","newKey","oldVKids","children","newVKids","oldHead","newHead","oldTail","length","newTail","props","keyed","newKeyed","createTextNode","createElementNS","createElement","len","appendChild","createVNode","createTextVNode","recycleNode","nodeType","nodeName","call","childNodes","CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE","constructableStyleCache","Map","constructableStyleTagFallbackCache","Component","Base","constructor","super","styles","this","obj","self","render_","renderer","render","results","state","fallbackCssString","rest","arguments","push","pop","h","dangerouslySetInnerHTML","unshift","vdom","options","oldVDom","concat","parentNode","shadowRoot","NOOP","cssString","adopt","element","async","getStringOnFallback","useStyleTag","noDefaultResets","signature","tag","adopter","elmnt","ShadowRoot","getShadowParent","constructable","get","CSSStyleSheet","set","adoptedStyleSheets","css","update","textContent","createStyleTag","cloneNode","adoptStyles","hasRenderer","mounted","then","isObj","unsubs","obi","$onChange","onStateChange","eventListener","to","ev","cb","opts","emit","event","detail","from","dispatchEvent","CustomEvent","bubbles","composed","initialUpdate","beforeInitialUpdate","getArgs","unmount","didMount","logic","subsequentUpdate","didUpdate"],"mappings":"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"}