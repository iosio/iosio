import{Subie as e,arrayIncludesItemFromArray as t,def as n,isFunc as a,isObj as u,extend as i}from"@iosio/util";let r=["$obi","$batching","$onChange","$getState","$merge","$path"];const o=t=>{let{sub:o,notify:b}=e(),l=[];const $=(c,g="")=>{const{sub:h,notify:s}=e();return((e,g="")=>{if(e.$obi)return e;n(e,"$obi",{enumerable:!1,value:!0}),n(e,"$batching",{enumerable:!1,value:{active:!1}}),n(e,"$onChange",{enumerable:!1,value:e=>h(e)}),n(e,"$onAnyChange",{enumerable:!1,value:e=>o(e)}),n(e,"$getState",{enumerable:!1,value:()=>Object.keys(e).reduce((t,n)=>a(e[n])?t:(t[n]=u(e[n])&&e[n].$obi?e[n].$getState():e[n],t),{})}),n(e,"$merge",{enumerable:!1,value:(e,n)=>{t.$batching.active=!0,a(e)?e(c):i(c,e),t.$batching.active=!1,n||(s(c,l),b(t,l)),l=[]}});for(let i in e){let o=e[i];if(a(o)||r.includes(i))continue;let h=g+(g?".":"")+i;u(o)&&$(e[i],h),n(e,i,{enumerable:!0,get:()=>o,set(e){e!==o&&(o=e,l.push(h),t.$batching.active||(s(c,[h]),b(t,[h]),l=[]))}})}return e})(c,g)};return $(t)},b=(n,a=[])=>({$onChange:u=>{const{sub:i,notify:r}=e(),o=n.$onAnyChange((e,n=[])=>t(a,n)&&r(e,n)),b=i(u);return()=>{o(),b()}}});export{o as obi,b as select};
