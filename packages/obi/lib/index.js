import{Subie as e,arrayIncludesItemFromArray as t,def as n,isFunc as a,isObj as r,extend as u}from"@iosio/util";const i=(n,a=[])=>({$onChange:r=>{const{sub:u,notify:i}=e(),s=n.$onAnyChange((e,n=[])=>t(a,n)&&i(e,n)),l=u(r);return()=>(s(),l())}});let s=["$obi","$batching","$onChange","$getState","$merge","$path","$select"];const l=t=>{let{sub:l,notify:o}=e(),b=[];const $=(c,g="")=>{const{sub:m,notify:h}=e();return((e,g="")=>{if(e.$obi)return e;n(e,"$obi",{enumerable:!1,value:!0}),n(e,"$batching",{enumerable:!1,value:{active:!1}}),n(e,"$onChange",{enumerable:!1,value:e=>m(e)}),n(e,"$onAnyChange",{enumerable:!1,value:e=>l(e)}),n(e,"$getState",{enumerable:!1,value:()=>Object.keys(e).reduce((t,n)=>a(e[n])?t:(t[n]=r(e[n])&&e[n].$obi?e[n].$getState():e[n],t),{})}),n(e,"$merge",{enumerable:!1,value:(e,n)=>{t.$batching.active=!0,a(e)?e(c):u(c,e),t.$batching.active=!1,n||(h(c,b),o(t,b)),b=[]}}),n(e,"$select",{enumerable:!1,value:(t=[])=>u({},{...e,...i(e,t)})});for(let u in e){let i=e[u];if(a(i)||s.includes(u))continue;let l=g+(g?".":"")+u;r(i)&&$(e[u],l),n(e,u,{enumerable:!0,get:()=>i,set(n){n!==i&&(r(n)&&r(i)&&e[u].$merge?e[u].$merge(n):(i=n,b.push(l),t.$batching.active||(h(c,[l]),o(t,[l]),b=[])))}})}return e})(c,g)};return $(t)};export{l as obi,i as select};
//# sourceMappingURL=index.js.map
