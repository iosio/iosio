import{isObj as t,isArray as e,isFunc as s,def as i,extend as r,raf as n,objectIsEmpty as o,CSSTextToObj as l}from"@iosio/util";const h=document,d="adoptedStyleSheets"in document,a=t=>{let e=h.createElement("style");return e.appendChild(h.createTextNode("")),(t||h.head).appendChild(e),t=>(e.appendChild(h.createTextNode(t)),e)},u={},c=(t,e)=>{let s=!1;return d&&(s=new CSSStyleSheet)[e?"replace":"replaceSync"](t),[s,t]},p=(t,e)=>{e=e||String;try{if(e==Boolean?t=[!0,1,"","1","true"].includes(t):"string"==typeof t&&(t=e==Number?Number(t):e==Object||e==Array?JSON.parse(t):t),{}.toString.call(t)==`[object ${e.name}]`)return{value:t,error:e==Number&&Number.isNaN(t)}}catch(t){}return{value:t,error:!0}},b=(t,e)=>!(!t.getAttribute||!t.localName)&&(e=t.getAttribute("is"),t.localName.includes("-")||e&&e.includes("-")),y=(s,i,r)=>{null===r||!1===r?s.removeAttribute(i):s.setAttribute(i,b(s)&&(t(r)||e(r))?JSON.stringify(r):r)},S=t=>t.replace(/([A-Z])/g,"-$1").toLowerCase(),m=t=>t.replace(/-(\w)/g,(t,e)=>e.toUpperCase()),g=!1,f=({h:t,render:h,setProperty:c})=>{let b="props",g=Symbol(),f=":host, *, *::before, *::after {box-sizing: border-box;} ",w={};const v=t=>{for(;t.parentNode&&(t=t.parentNode);)if(t instanceof ShadowRoot)return t;return document},C=a();class x extends HTMLElement{constructor(){super(),this.context=w,this.unsubs=[],this.state={},this.observe=null;let{initAttrs:i,shadow:a,rootSheet:p,noRerender:y,tag:S}=this.constructor,m=a?this.attachShadow({mode:!0===a?"open":a}):this;this[b]={},this.render=this.render.bind(this),this.mounted=new Promise(t=>this._mount=t);const g=(t,s)=>{let i=a?m:v(this),r="",n=d&&!s?t=>{let s=e(t)?t[0]:t;s&&![].concat(i.adoptedStyleSheets).includes(s)&&(i.adoptedStyleSheets=[...i.adoptedStyleSheets,s])}:t=>{e(t)&&t[1]&&(r+=t[1])};return[].concat(t).forEach(n),r};let x="",N=0,R=!1;const A=({css:e,noResets:s,globalFallback:i,useStyleTag:r,styleSheets:n,children:o})=>{if(N>0)return console.error("<CSS/> should only be used once. Use a style tag to include additional styles."),null;if(N++,!1!==R)return R;let l=e||o||"";return!s&&a&&(l=f+l),d&&!r?(g(p),0===p.cssRules.length&&p.replaceSync(l),n&&g(n),R=null):(x=l+g(p,!0)+(n?g(n,!0):""),i&&!u[S]?(u[S]=!0,C(x),R=null):R=t("style",{},x)),R};let U;const E=({children:t,...e})=>{if(!this.hasMounted&&o(e))return U=!0,t;if(U&&o(e))return t;U=!1;let s,i={},r=this.attributes;for(s=r.length;s--;)i[r[s].name]=r[s].value;for(let t in e)c(this,t,e[t],i[t],!1);return t};this.setState=t=>(this.state={...this.state,...s(t)?t(this.state):t||{}},this.update()),this.observeObi=t=>[].concat(t).forEach(t=>t.$onChange&&this.unsubs.push(t.$onChange(this.update)));const M=()=>(this._observesStyle&&(this[b].style=l(this.style.cssText)),[r({Host:E,CSS:A,host:this},this[b]),this.state,this.context]),T=()=>{let t=M();this.willMount(...t),this.willRender(...t),h(this.render(...t),m),N=0,n(()=>{this.unsubs.push(this.lifeCycle(...t)),this.didRender(...t),this.didMount(...t),this.hasMounted=!0})},O=()=>{let t=M(),e=this.willRender(...t);this.willUpdate(...t),this.shouldUpdate&&(e=this.shouldUpdate(...t)),y||!e&&void 0!==e||(h(this.render(...t),m),N=0,this.didUpdate(...t),this.didRender(...t))};this.update=()=>(this.processing||(this.processing=this.mounted.then(t=>{this.hasMounted?O():T(),this.processing=!1})),this.processing),this.emit=(t,e,s,i)=>(s||this).dispatchEvent(new CustomEvent(t,{detail:e,bubbles:!0,composed:!0,...i})),this.destroy=()=>{this.willUnmount(),h(null,m),this.unsubs.forEach(t=>s(t)&&t())};let $=i.length;for(;$--;)i[$](this);this.update()}connectedCallback(){this.hasMounted||(this.observe&&this.observeObi(this.observe),this._mount())}disconnectedCallback(){this.isConnected||this.destroy()}attributeChangedCallback(t,e,s){this[g]!==t&&e!==s&&("style"===t&&this._observesStyle?this.update():this[m(t)]=s)}static get observedAttributes(){let{propTypes:t,prototype:e}=this;if(this.initAttrs=[],!t)return[];let s=Object.keys(t).map(s=>{let r=S(s),n=t[s].name?{type:t[s]}:t[s];return s in e||i(e,s,{get(){return this[b][s]},set(t){let{value:e,error:i}=p(t,n.type);i&&null!=e&&console.error(`[${s}] must be type [${n.type.name}]`),e!==this[b][s]&&(n.reflect&&this.mounted.then(()=>{this[g]=r,y(this,r,n.type!==Boolean||e?e:null),this[g]=!1}),this[b][s]=e,this.update())}}),n.value&&this.initAttrs.push(t=>t[s]=n.value),r});return this.prototype._observesStyle=s.includes("style"),s}willMount(){}willRender(){}render(){}didRender(){}willUpdate(){}didUpdate(){}didMount(){}lifeCycle(){}willUnmount(){}}const N=(e,s,i={})=>{var r,n;let o,l=s.prototype instanceof x;return d&&(o=new CSSStyleSheet),l&&(s.rootSheet=o,s.tag=e),customElements.define(e,l?s:(n=r=class extends x{constructor(...t){super(...t),this.render=s}},r.rootSheet=o,r.tag=e,r.propTypes=i.propTypes,r.shadow=i.shadow,r.noRerender=i.noRerender,n)),s=>t(e,s)};let R,A,U=()=>{};return R=N("x-x",U),A=N("x-shadow",U,{shadow:!0}),{x:N,X:R,XShadow:A,Element:x,provide:(t,e)=>w[t]=e}};export{d as CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE,g as TEST_ENV,m as attrToProp,f as createBase,c as createStyleSheet,h as d,p as formatType,u as globalStyleTagCache,a as headStyleTag,b as isCustomElement,S as propToAttr,y as updateAttribute};
