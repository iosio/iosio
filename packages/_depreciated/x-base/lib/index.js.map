{"version":3,"file":"index.js","sources":["../src/utils.js","../src/createBase.js"],"sourcesContent":["import {isObj, isArray, def, isFunc} from \"@iosio/util\";\n\nexport const d = document;\n\n/*------------------ STYLES -------------------------- */\n\nexport const CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE = \"adoptedStyleSheets\" in document;\n\n/**\n * creates a single style sheet. returns a function to update the same sheet\n * @param {node|| null} mount - pass the node to mount the style element to defaults to document head\n * @returns {function} for adding styles to the same stylesheet\n */\nexport const headStyleTag = (mount) => {\n    let style = d.createElement('style');\n    style.appendChild(d.createTextNode(\"\"));\n    (mount || d.head).appendChild(style);\n    return (css) => (style.appendChild(d.createTextNode(css)), style);\n};\n\n\n/*------------------ WEB COMPONENT -------------------------- */\n/**\n * for parsing the incoming attributes into consumable props\n * @param value\n * @param type\n * @returns {{error: boolean, value: *}}\n */\nexport const formatType = (value, type) => {\n    type = type || String;\n    if (type == Boolean) value = [true, 1, \"\", \"1\", \"true\"].includes(value);\n    else if (typeof value == \"string\") {\n        value = type == Number\n            ? Number(value) : type == Object || type == Array\n                ? JSON.parse(value) : value;\n    }\n    if ({}.toString.call(value) == `[object ${type.name}]`) return {\n        value,\n        error: type == Number && Number.isNaN(value)\n    };\n    return {value, error: true};\n};\n\nexport const isCustomElement = (el, isAttr) => {\n    if (!el.getAttribute || !el.localName) return false;\n    isAttr = el.getAttribute('is');\n    return el.localName.includes('-') || isAttr && isAttr.includes('-');\n};\n\n/**\n * will set or remove the attribute based on the truthyness of the value.\n * if the type of value is object or array and the node is a custom element, it will json stringify the value\n * @param node\n * @param attr\n * @param value\n */\nexport const updateAttribute = (node, attr, value) => {\n    (value === null || value === false || value === 'null' || value === 'false')\n        ? node.removeAttribute(attr)\n        : node.setAttribute(attr, isCustomElement(node) && (isObj(value) || isArray(value)) ? JSON.stringify(value) : value);\n};\n\nexport const propToAttr = (prop) => prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\nexport const attrToProp = (attr) => attr.replace(/-(\\w)/g, (all, letter) => letter.toUpperCase());\n\n\n/**\n * @param cssText\n * @param async\n * @returns {*[]} - [0] constructable style sheet, [1] css text\n */\nexport const createStyleSheet = (cssText, async) => {\n    let sheet = false;\n    if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE) {\n        sheet = new CSSStyleSheet();\n        sheet[async ? 'replace' : 'replaceSync'](cssText);\n    }\n    return [sheet, cssText];\n};\n\n\nexport const getShadowParent = elmnt => {\n    while (elmnt.parentNode && (elmnt = elmnt.parentNode)) if (elmnt instanceof ShadowRoot) return elmnt;\n    return document;\n};\n\n\n/*\n* adopts style sheets to the shadowRoot, shadowParent or the document\n* @param sheets {array|CSSStyleSheet}\n* @returns {string}\n*/\nexport const adoptSheets = ({styleSheets, getCombined, element}) => {\n    let adopter = element.shadowRoot || getShadowParent(element);\n\n    let combinedCSSTextIfNotAdoptable = '';\n\n    const constructable = customArrayOrSheet => {\n        let sheet = isArray(customArrayOrSheet) ? customArrayOrSheet[0] : customArrayOrSheet;\n        if (sheet && !([].concat(adopter.adoptedStyleSheets).includes(sheet))) {\n            adopter.adoptedStyleSheets = [...adopter.adoptedStyleSheets, sheet];\n        }\n    };\n\n    const combinedText = customArrayOrSheet => {\n        if (isArray(customArrayOrSheet) && customArrayOrSheet[1]) {\n            combinedCSSTextIfNotAdoptable = combinedCSSTextIfNotAdoptable + customArrayOrSheet[1]\n        }\n    };\n\n    let adopt = CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE && !getCombined ? constructable : combinedText;\n\n    [].concat(styleSheets).forEach(adopt);\n\n    return combinedCSSTextIfNotAdoptable\n};\n\nconst constructableStyleCache = {};\nconst constructableStyleTagFallbackCache = {};\n\nexport const DEFAULT_SHADOWROOT_HOST_CSS_RESETS = `:host, *, *::before, *::after {box-sizing: border-box;} `;\n\nexport const createStyleTag = (css) => {\n    let style = document.createElement('style');\n    let textNode = document.createTextNode(css);\n    style.appendChild(textNode);\n    return {\n        element: style,\n        update: (css) => textNode.replaceWith(document.createTextNode(css))\n    };\n};\n\nexport const adoptStyles = (tag, element, cssString, async, useStyleTag) => {\n\n    cssString = (element.shadowRoot ? DEFAULT_SHADOWROOT_HOST_CSS_RESETS : '') + cssString;\n\n\n    if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE && !useStyleTag) {\n        let adopter = element.shadowRoot || getShadowParent(element);\n\n        let constructable = constructableStyleCache[tag];\n        if (!constructable) {\n            constructable = new CSSStyleSheet();\n            constructable[async ? 'replace' : 'replaceSync'](cssString);\n            constructableStyleCache[tag] = constructable;\n        }\n        if (!([].concat(adopter.adoptedStyleSheets).includes(constructable))) {\n            adopter.adoptedStyleSheets = [...adopter.adoptedStyleSheets, constructable];\n        }\n    } else {\n        let style = constructableStyleTagFallbackCache[tag];\n        if (!style) {\n            style = createStyleTag(cssString).element;\n            constructableStyleTagFallbackCache[tag] = style;\n        }\n        (element.shadowRoot || element).appendChild(style.cloneNode(true));\n    }\n};\n\nexport const select = (host, selector) => (host.shadowRoot || host).querySelector(selector);\n\nexport const createRefs = (element, refs, selector) => {\n    return refs.reduce((acc, curr) => (acc[curr] = select(element, (selector || '') + curr), acc), {})\n};\n\nexport const createRefsFromIDs = (element, refs) => createRefs(element, refs, '#');\n\nconst tagTemplateCache = {};\n\nexport const appendTemplate = (tag, element, templateStr) => {\n    if (!tag || !element || !templateStr) return;\n    let el = element.shadowRoot || element;\n    let temp = tagTemplateCache[tag];\n    if (!temp) {\n        temp = document.createElement('template');\n        temp.innerHTML = templateStr;\n        tagTemplateCache[tag] = temp;\n    }\n    el.appendChild(temp.content.cloneNode(true));\n};\n\nexport const UpdatableTemplate = (host) => {\n    let temp; // try caching again\n    return (html) => {\n        temp = document.createElement('template');\n        temp.innerHTML = html;\n        host.innerHTML = '';\n        host.appendChild(temp.content.cloneNode(true));\n    }\n};\n\n\n\nexport const getElementProps = (element) => {\n    let hostNodeProps = {}, i, a = element.attributes;\n    for (i = a.length; i--;) hostNodeProps[a[i].name] = a[i].value;\n    return hostNodeProps;\n};\n\n\nexport const makeProxyObj = (fallBackGetter) => {\n    return new Proxy({}, {\n        get(target, key) {\n            let prop = target[key];\n            if (target[key]) return target[key];\n            else {\n                prop = fallBackGetter(key);\n                target[key] = prop;\n                return prop;\n            }\n        }\n    });\n};\n\n\n\nexport const proxyAttrs = (element, updateAttr) => {\n    return new Proxy({}, {\n        set(target, key, value) {\n            updateAttr && updateAttribute(element, key, value);\n        },\n        get(target, key) {\n            return element.getAttribute(key);\n        }\n    });\n};\n\nconst PromiseBatch = () => {\n    let resolve, processing,\n        promise = new Promise(mount => (resolve = mount));\n    return {\n        promise,\n        resolve,\n        processing,\n        updater: (fn) => (...args) => {\n            console.log('updating')\n            if (!processing) processing = promise.then(_ => {\n                fn && fn(...args);\n                processing = false;\n            });\n        }\n    }\n};\n\n\nexport const ProxyProps = (element) => {\n    let _props = {};\n    // let elementMount;\n    // let mounted = new Promise(mount => (elementMount = mount));\n    // let processing;\n\n    const {promise, resolve, updater} = PromiseBatch();\n\n    return {\n        mount: resolve,\n        mounted: promise,\n        def: (props, updateFn, reflect) => {\n\n            const update = updater(updateFn);\n\n            Object.keys(props).forEach((key) => {\n\n                _props[key] = props[key];\n\n                def(element, key, {\n                    set(val) {\n                        if (_props[key] !== val) {\n                            _props[key] = val;\n                            reflect && updateAttribute(element, key, val);\n                            update(_props);\n                        }\n                    },\n                    get() {\n                        return _props[key];\n                    }\n                })\n            });\n\n        }\n    }\n};\n\nexport const reflectPropsToAttrs = (element, props) => {\n    let _props = {};\n\n    const {promise, resolve, updater} = PromiseBatch();\n\n    Object.keys(props).forEach((key) => {\n\n        const updateIt = (key, val) => {\n            updateAttribute(element, key, val);\n        };\n\n        const update = updater(updateIt);\n\n        def(element.prototype, key, {\n\n            set(val) {\n\n                console.log('setting property', key, 'with', val);\n\n                let type = props[key],\n                    _val = val;\n\n                if (isFunc(type)){\n                    _val = type(val);\n                } else {\n                    console.log('formatting type', val , type);\n                    _val = formatType(_val, type).value;\n                }\n\n                if (_props[key] !== _val) {\n                    _props[key] = _val;\n                    console.log('updating attribute', key, _val);\n                    promise.then(() =>{\n                        updateAttribute(element, key, _val)\n                    });\n                }\n\n            },\n            get() {\n                return _props[key];\n            }\n        })\n    });\n    return {\n        mount: (self) => {\n            element = self;\n            resolve();\n        },\n    }\n};\n\n\nexport const emit = (from, event, detail, opts = {}) => from.dispatchEvent(\n    new CustomEvent(event, {detail: detail, bubbles: true, composed: true, ...opts})\n);\n\nconst IGNORE_ATTR = Symbol();\nconst reactiveProps = {\n    construct: (self) => {\n        let {initAttrs} = self.constructor;\n        self.prevProps = {};\n        self.props = {};\n        self.mounted = new Promise(mount => (self._mount = mount));\n        self.update = () => {\n            if (!self.processing) self.processing = self.mounted.then(_ => {\n                !self.hasMounted\n                    ? (self.didMount && self.didMount(self.props, self.prevProps), self.hasMounted = true )\n                    : self.didUpdate && self.didUpdate(self.props, self.prevProps);\n                self.processing = false;\n            });\n            return self.processing;\n        };\n        let length = initAttrs.length;\n        while (length--) initAttrs[length](self);\n        self.update();\n    },\n    observedAttrs: (self, existingAttrs = []) => {\n\n        let {prototype, propTypes} = self;\n        self.initAttrs = [];\n        if (!propTypes) return [];\n\n        return Object.keys(propTypes).map(prop => {\n            let attr = propToAttr(prop);\n            let schema = propTypes[prop].name ? {type: propTypes[prop]} : propTypes[prop];\n            if (!(prop in prototype)) {\n                def(prototype, prop, {\n                    get() {\n                        return this.props[prop]\n                    },\n                    set(nextValue) {\n                        let {value, error} = formatType(nextValue, schema.type);\n                        if (error && value != null) console.error(`[${prop}] must be type [${schema.type.name}]`);\n                        if (value === this.props[prop]) return;\n                        if (schema.reflect) {\n                            this.mounted.then(() => {\n                                this[IGNORE_ATTR] = attr;\n                                updateAttribute(\n                                    this,\n                                    attr,\n                                    schema.type === Boolean && !value\n                                        ? null\n                                        : value\n                                );\n                                this[IGNORE_ATTR] = false;\n                            });\n                        }\n                        this.prevProps[prop] = this.props[prop];\n                        this.props[prop] = value;\n                        this.update();\n                    }\n                });\n            }\n            schema.value && self.initAttrs.push(self => (self[prop] = schema.value));\n            return attr;\n        });\n    },\n    connect:(self) => {\n        if (!self.hasMounted) self._mount();\n    },\n    attrChange:(attr, oldValue, newValue, self) => {\n        if (self[IGNORE_ATTR] === attr || oldValue === newValue) return;\n        self[attrToProp(attr)] = newValue;\n    }\n};\n\nexport const createReactiveProps = () => {\n\n    return reactiveProps\n};\n\nconst {construct, observedAttrs, connect, attrChange} = reactiveProps;\n\n\n\nexport class ReactiveElement extends HTMLElement{\n    static get observedAttributes(){\n        return observedAttrs(this);\n    }\n    constructor() {\n        super();\n        construct(this)\n    }\n    connectedCallback(){\n        connect(this);\n    }\n    attributeChangedCallback(attr, old, _new){\n        attrChange(attr, old, _new, this);\n    }\n}\n\n\n\n\n/*------------------ CONSTANTS -------------------------- */\n\nexport const TEST_ENV = process.env.NODE_ENV === 'test';\n\n","import {\n    formatType,\n    updateAttribute,\n    propToAttr,\n    attrToProp,\n    TEST_ENV,\n    adoptSheets,\n    CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE, headStyleTag,\n    DEFAULT_SHADOWROOT_HOST_CSS_RESETS\n\n} from \"./utils\";\n\nimport {isArray, raf, CSSTextToObj, def, isFunc, objectIsEmpty, extend} from \"@iosio/util\";\n\n\nexport const createBase = ({h, render, setProperty}) => {\n\n    const globalStyleTagCache = {}; // cache the instance css to the tagName\n\n    let PROPS = 'props',\n        IGNORE_ATTR = Symbol(),\n\n        context = {};\n\n    const getShadowParent = element => {\n        while (element.parentNode && (element = element.parentNode)) {\n            if (element instanceof ShadowRoot) return element;\n        }\n        return document;\n    };\n\n\n    const provide = (namespace, attach) => context[namespace] = attach;\n\n\n    const globalStyles = headStyleTag();\n\n\n    /* lots of inspiration from atomico, stencil, and preact*/\n    class Element extends HTMLElement {\n\n        constructor() {\n            super();\n            this.context = context;\n            this.unsubs = [];\n            this.state = {};\n            this.observe = null;\n            // the statically set fields from the class that extends this\n            let {initAttrs, shadow, rootSheet, noRerender, tag} = this.constructor;\n\n            let root = !shadow ? this : this.attachShadow({mode: shadow === true ? 'open' : shadow});\n\n            this[PROPS] = {};\n\n            this.render = this.render.bind(this);\n\n            // store a pending promise to mounted.\n            // Promise is resolved in connectedCallback when mount is called\n            this.mounted = new Promise(mount => (this._mount = mount));\n\n\n            let combinedCSSText = '', cssOncePerRenderVerify = 0, renderStyle = false;\n            /**\n             * optionally use constructable style sheets with fall backs if not supported\n             * @param css {string} - css text\n             * @param noResets {boolean} - exclude the default box-sizing reset on the :host\n             * @param globalFallback {boolean} - if no constructableStylesheets then optionally allow a style tag in the head of the document instead of a style tag\n             * @param useStyleTag {boolean} - use a style tag even if constructableStylesheets\n             * @param styleSheets {array} - an array of style sheets made with createStyleSheet\n             * @param children - child vNodes\n             * @returns {*}\n             */\n            const CSS = ({css, noResets, globalFallback, useStyleTag, styleSheets, children}) => {\n                if (cssOncePerRenderVerify > 0) {\n                    // console.error('<CSS/> should only be used once. Use a style tag to include additional styles.');\n                    return null;\n                }\n                cssOncePerRenderVerify++;\n                // dip out if we've got our static non changing styles already..\n                if (renderStyle !== false) return renderStyle;\n                let cssText = css || children || '';\n                // if using shadow then include the resets by default if noResets is not explicitly set to true.\n                if (!noResets && shadow) cssText = DEFAULT_SHADOWROOT_HOST_CSS_RESETS + cssText;\n\n                if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE && !useStyleTag) {\n                    adoptSheets({styleSheets: rootSheet, element: this});\n                    rootSheet.cssRules.length === 0 && rootSheet.replaceSync(cssText);\n                    styleSheets && adoptSheets({styleSheets: styleSheets, element: this});\n                    renderStyle = null;\n                } else {\n                    combinedCSSText = cssText\n                        + adoptSheets({styleSheets: rootSheet, element: this, getCombined: true})\n                        + (styleSheets ? adoptSheets({\n                            styleSheets: styleSheets,\n                            element: this,\n                            getCombined: true\n                        }) : '');\n                    if (globalFallback && !globalStyleTagCache[tag]) {\n                        globalStyleTagCache[tag] = true;\n                        globalStyles(combinedCSSText);\n                        renderStyle = null;\n                    } else renderStyle = h('style', {}, combinedCSSText);\n                }\n                return renderStyle;\n            };\n\n\n            let lastSelfHostPropsEmpty;\n            const Host = ({children, ...selfProps}) => {\n                //can skip patching the host props during the first render if no props are provided\n                if (!this.hasMounted && objectIsEmpty(selfProps)) return (lastSelfHostPropsEmpty = true, children);\n                if (lastSelfHostPropsEmpty && objectIsEmpty(selfProps)) return children;\n                lastSelfHostPropsEmpty = false;\n                // convert the attributes from this element into props format\n                let hostNodeProps = {}, i, a = this.attributes;\n                for (i = a.length; i--;) hostNodeProps[a[i].name] = a[i].value;\n                //apply host vnode props on 'this', merge in and potentially override individual properties that exist\n                for (let i in selfProps) setProperty(this, i, selfProps[i], hostNodeProps[i], false);\n                return children;\n            };\n\n            this.setState = nextState => {\n                this.state = {...this.state, ...(isFunc(nextState) ? nextState(this.state) : (nextState || {}))};\n                return this.update();//can call .then(...)\n            };\n\n            this.observeObi = obis =>\n                [].concat(obis).forEach(obi =>\n                    obi.$onChange && this.unsubs.push(obi.$onChange(this.update)));\n\n            const renderArgs = () => {\n                // if watching the style property, convert the style string ('width:100%;') into an object ({width: '100%'})\n                if (this._observesStyle) this[PROPS].style = CSSTextToObj(this.style.cssText);\n                return [\n                    extend({Host, CSS, host: this}, this[PROPS]),\n                    this.state,\n                    this.context\n                ];\n            };\n\n            const initialRenderer = () => {\n                let next = renderArgs();\n                this.willMount(...next);\n                this.willRender(...next);\n                render(this.render(...next), root);\n                cssOncePerRenderVerify = 0;\n                let postInitial = () => {\n                    this.unsubs.push(this.lifeCycle(...next)); // optionally return subscriptions to unsub on detach\n                    this.didRender(...next);\n                    this.didMount(...next);\n                };\n                this.hasMounted = true;\n                // Removing this functionality during testing makes life easier.\n                !TEST_ENV ? setTimeout(postInitial) : postInitial();\n            };\n\n            const subsequentRenderer = () => {\n                let next = renderArgs();\n                let shouldRerender = this.willRender(...next); //\n                this.willUpdate(...next);\n                if (this.shouldUpdate) shouldRerender = this.shouldUpdate(...next);\n                // returning a falsy value other than undefined will prevent rerender\n                if (noRerender || (!shouldRerender && (shouldRerender !== undefined))) return;\n                render(this.render(...next), root);\n                cssOncePerRenderVerify = 0;\n                this.didUpdate(...next);\n                this.didRender(...next);\n            };\n\n            this.update = () => {\n                if (!this.processing) this.processing = this.mounted.then(_ => {\n                    !this.hasMounted ? initialRenderer() : subsequentRenderer();\n                    this.processing = false;\n                });\n                return this.processing;\n            };\n\n            this.emit = (name, detail, from, options) => (from || this).dispatchEvent(\n                new CustomEvent(name, {detail, bubbles: true, composed: true, ...options})\n            );\n\n            this.destroy = () => {\n                this.willUnmount();\n                render(null, root);\n                this.unsubs.forEach(fn => isFunc(fn) && fn());\n            };\n\n            let length = initAttrs.length;\n            while (length--) initAttrs[length](this);\n            this.update();\n        }\n\n        connectedCallback() {\n            // connected callback may be called inadvertently, so check this.\n            if (this.hasMounted) return;\n            this.observe && this.observeObi(this.observe);\n            // resolve the pending promise that was set to this.mounted.\n            this._mount();\n        }\n\n        disconnectedCallback() {\n            // web components may inadvertently call this, so check if its connected before calling destroy.\n            // can happen if the node is being moved ex:  parent.insertBefore(node, targetNode).\n            if (this.isConnected) return;\n            this.destroy();\n        }\n\n        attributeChangedCallback(attr, oldValue, newValue) {\n            // if we are setting our own attribute that we are tracking, then ignore this update.\n            if (this[IGNORE_ATTR] === attr || oldValue === newValue) return;\n            // opt-in notify for styles\n            if (attr === 'style' && this._observesStyle) this.update();\n            // else convert kabob-case to camelCase\n            else this[attrToProp(attr)] = newValue;\n        }\n\n        /*  -- a little recap on prototype --\n            When a constructor (a.k.a. pseudo classical inheritance) function is built,\n            the newly created objects inherit the prototype properties of the constructor function\n            and that’s the critical feature of constructors. They (constructor functions)\n            are built for the initialization of newly created objects.*/\n\n        /*  let the prototype know what attributes to observe\n            called while constructing the class / creating the prototype. */\n        static get observedAttributes() {\n            let {\n                propTypes, // get the statically set propTypes.\n                prototype // prototype - the soon to be - newly instantiated class.\n            } = this; // 'this' will references the constructor when used inside static methods.\n\n            this.initAttrs = [];\n\n            if (!propTypes) return [];\n            /* inspired by atomico  */\n            let observedAttr = Object.keys(propTypes).map(prop => {\n                let attr = propToAttr(prop);// convert the camelCase to kabob-case.\n                let schema = propTypes[prop].name ? {type: propTypes[prop]} : propTypes[prop];\n                //dynamically build the setters and getters for the prototype during the construction phase.\n                if (!(prop in prototype)) { // ignores properties that exist, like style and className\n                    // def = (obj, prop, handlers) => Object.defineProperty(obj, prop, handlers),\n                    def(prototype, prop, {\n                        // keep an internal reference to the observed properties on this.props.\n                        // provide an access getter.\n                        get() {// <--- since this is not a lexical scope function aka () => { };\n                            // then 'this' (in this scope) will reference the prototype.\n                            return this[PROPS][prop]\n                        },\n                        // react to updates when the value is set on the instance.\n                        set(nextValue) {\n                            // format the incoming value into the type that it is defined in on the propTypes object\n                            // ex: if its an Object, then JSON.parse the value\n                            let {value, error} = formatType(nextValue, schema.type);\n                            if (error && value != null) console.error(`[${prop}] must be type [${schema.type.name}]`);\n                            // if the value is the same, then dip out.\n                            if (value === this[PROPS][prop]) return;\n                            // if the value is meant to be reflected\n                            // then set it as an attribute\n                            if (schema.reflect) { // several sequential updates are deferred/debounced with the pending promise\n                                this.mounted.then(() => { // and are only set after the component has finished constructing.\n                                    // setting IGNORE_ATTR ignores attribute during attributeChangedCallback\n                                    // because we handle our own update.\n                                    this[IGNORE_ATTR] = attr;\n                                    //either set or remove the attribute.\n                                    updateAttribute(\n                                        this,\n                                        attr,\n                                        schema.type === Boolean && !value\n                                            ? null\n                                            : value\n                                    );\n                                    this[IGNORE_ATTR] = false;\n                                });\n                            }\n                            this[PROPS][prop] = value;\n                            this.update();\n                        }\n                    });\n                }\n                // prime the default attributes if the propTypes schema has default value.\n                // will initialize in the constructor of the prototype.\n                schema.value && this.initAttrs.push(self => (self[prop] = schema.value));\n                return attr;\n            });\n            // let the prototype know to listen for style changes here since ('style' in prototype) is true\n            // and since we want more control over how the style is updated ex: {...userStyles, ...ourStyles}\n            this.prototype._observesStyle = observedAttr.includes('style');\n            return observedAttr;\n        };\n\n        willMount() { // called once before render\n        }\n\n        willRender() { // called before every render, optionally return false to prevent any further re-rendering\n            // will still render one time\n            // return false; // but no more rendering!\n        }\n\n        render() {\n        }\n\n        didRender() { // called after every render\n        }\n\n        willUpdate() { // called before every render besides the first\n        }\n\n        didUpdate() { // called after every render besides the first\n        }\n\n        didMount() { // called once after first render\n        }\n\n        lifeCycle() { // same as didMount but optionally return a callback to be called during willUnmount\n            // return ()=> subscription.unsubscribe();\n        }\n\n        willUnmount() {\n        }\n\n    }\n\n\n    const x = (tag, element, config = {}) => {\n\n        let rootSheet,\n            isElement = element.prototype instanceof Element;\n\n        if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE) rootSheet = new CSSStyleSheet();\n\n        if (isElement) {\n            element.rootSheet = rootSheet;\n            element.tag = tag;\n        }\n\n        customElements.define(tag,\n            isElement ? element : class extends Element {\n                static rootSheet = rootSheet;\n                static tag = tag;\n                static propTypes = config.propTypes;\n                static shadow = config.shadow;\n                static noRerender = config.noRerender;\n                render = element\n            }\n        );\n\n        return (props) => h(tag, props);\n    };\n\n    let X, XShadow, fn = () => {\n    };\n\n\n    if (!TEST_ENV && !customElements.get('x-x') && !customElements.get('x-shadow')) {\n        X = x('x-x', fn);\n        XShadow = x('x-shadow', fn, {shadow: true});\n    }\n\n    return {\n        x,\n        X,\n        XShadow,\n        Element,\n        provide\n    }\n};\n\n\n/*\n------using static template and css\n\n\n  if (tagTemplateCache[tag]) {\n                    root.appendChild(tagTemplateCache[tag].content.cloneNode(true))\n                }else{\n\n                    if ( !tagTemplateCache[tag]) {\n                        template.innerHTML = root.innerHTML;\n                        tagTemplateCache[tag] = template;\n                    }\n                }\n\n\n\n        let base, noRenderResults, staticTemplate;\n        const initialRenderer = () => {\n            let next = renderArgs();\n            this.willMount(...next);\n            this.willRender(...next);\n\n            if (isObj(this.render)) {\n                staticTemplate = true;\n\n\n                const {html, css} = this.render;\n                // template\n                if (!tagTemplateCache[tag]) {\n                    if (html) template.innerHTML = html;\n                    tagTemplateCache[tag] = template;\n                }\n                if (css) {\n                    if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE) {\n                        // console.log('constructable style sheets av', css)\n                        adoptSheets([rootSheet]);\n                        if (rootSheet.cssRules.length === 0) {\n                            rootSheet.replaceSync(DEFAULT_SHADOWROOT_HOST_CSS_RESETS + css);\n                        }\n\n                    }\n                }\n\n\n                root.appendChild(tagTemplateCache[tag].content.cloneNode(true));\n            } else if (isFunc(this.render)) {\n                let results = this.render(...next);\n                if (results) {\n\n                    let mountPoint = createElem(usingVHost ? 'template' : results.name);\n                    appendChild(root, mountPoint);\n                    base = patch(usingVHost && shadow ? root : mountPoint, results);\n\n                } else noRenderResults = true;\n            }\n\n            let postInitial = () => {\n                this.unsubs.push(this.lifeCycle()); // optionally return subscriptions to unsub on detach\n                // adding visibility inherit next tick after render will prevent flash of un-styled content. (inspired by stencil.js)\n                // Removing this functionality during testing makes life easier.\n                // !TEST_ENV && updateAttribute(this, COMPONENT_MOUNTED_ATTRIBUTE, '');\n                this.didRender(...next);\n                this.didMount(...next);\n            };\n            this.hasMounted = true;\n            // !TEST_ENV ? raf(postInitial) :\n            postInitial();\n        };\n */\n/*\n\n\n\n    abstraction for sharing events on the window\n\n    const Events = ()=>{\n        window.addEventListener('dataChange', notifySubs)\n        ...\n        return{\n            emit,\n            on,\n            off,\n        }\n    }\n\n\n    events.emit('dataChange', 'namespace', {loggedIn: true })\n\n    events.on('dataChange', 'namespace', ({loggedIn})=>{\n        //do something\n    });\n\n */\n\n\n/*\n    constructor() {\n        super()\n\n\n        // this._observer = new MutationObserver(this._onMutation);\n    }\n\n\n    _onMutation = mutationsList => {\n        const newProps = mutationsList.reduce((props, mutation) => {\n            if (mutation.type === \"attributes\") {\n                const propKey = mutation.attributeName;\n                props[propKey] = this.getAttribute(propKey);\n            }\n            return props;\n        }, {});\n        // console.log('childlist mutated', mutationsList)\n        // console.log(newProps)\n        // this.update();\n        // this.setProps(newProps);\n    };\n\n    _startObserver = () => {\n\n\n        // this._observer.observe(this, {attributes: true});\n    };\n\n       const handler = {\n            set(target, key, value) {\n                console.log(`Setting value ${key} as ${value}`)\n                target[key] = value;\n            },\n        };\n\n        this.styles = new Proxy(this.style, handler);\n */\n\n// if ( usingVHost && shadow) {\n//\n//     // let mountPoint = createElem(usingVHost ? 'template');\n//     // usingVHost &&\n//\n//     appendChild(template.content, createElem('template'));\n//\n//     console.log('using vhost', !!usingVHost);\n//     console.log('using shadow', !!shadow);\n//     console.log('tmp', template);\n//     console.log('tmp content', template.content);\n//     // if using vHost and shadowDom then patch the root, else patch the mount point\n//\n//     // console.log(template.content.firstChild)\n//     //usingVHost && shadow ? template.content :\n//\n//     base = patch(template.content, results);\n//\n//     // base = patch(usingVHost && shadow ? template.content : template.content.firstChild, results);\n//\n//     root.appendChild(template.content.cloneNode(true));\n//\n//     console.log(root.innerHTML);\n//     console.log('------------');\n//\n//\n// }\n// else if ( usingVHost) {\n//\n//     // let mountPoint = createElem(usingVHost ? 'template');\n//     // usingVHost &&\n//\n//     appendChild(template.content, createElem('template'));\n//\n//     console.log('using vhost', !!usingVHost);\n//     console.log('using shadow', !!shadow);\n//     console.log('tmp', template);\n//     console.log('tmp content', template.content);\n//     // if using vHost and shadowDom then patch the root, else patch the mount point\n//\n//     // console.log(template.content.firstChild)\n//     //usingVHost && shadow ? template.content :\n//\n//     base = patch(template.content.firstChild, results);\n//\n//\n//     // base = patch(usingVHost && shadow ? template.content : template.content.firstChild, results);\n//\n//     root.appendChild(template.content.cloneNode(true));\n//\n//     console.log(root.innerHTML);\n//     console.log('------------');\n//\n//\n// }else{\n//     // let mountPoint = createElem(usingVHost ? 'template');\n//     // usingVHost &&\n//\n//     appendChild(template.content, createElem(results.name));\n//\n//     console.log('using vhost', !!usingVHost);\n//     console.log('using shadow', !!shadow);\n//     console.log('tmp', template);\n//     console.log('tmp content', template.content);\n//     // if using vHost and shadowDom then patch the root, else patch the mount point\n//\n//     // console.log(template.content.firstChild)\n//     //usingVHost && shadow ? template.content :\n//\n//     base = patch(template.content.firstChild, results);\n//\n//\n//     // base = patch(usingVHost && shadow ? template.content : template.content.firstChild, results);\n//\n//     root.appendChild(template.content.cloneNode(true));\n//\n//     console.log(root.innerHTML);\n//     console.log('------------');\n//\n// }\n\n\n// --------------- OG ---\n// import {\n//     formatType,\n//     updateAttribute,\n//     propToAttr,\n//     attrToProp,\n//     createElem,\n//     appendChild,\n//     TEST_ENV,\n//     def, extend, isFunc, isObj, objectIsEmpty,\n//     globalStyles,\n//     raf,\n//     isArray,\n//     CSSTextToObj,\n//     globalStyleTagCache,\n//     CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE\n// } from \"./utils\";\n//\n//\n// import {\n//     h,\n//     patch,\n//     removeHandlers,\n//     HOST_TYPE,\n//     patchProperty,\n// } from \"./vdom\";\n//\n//\n// // PROPS = Symbol(),\n// let PROPS = 'props',\n//     IGNORE_ATTR = Symbol(),\n//     DEFAULT_SHADOWROOT_HOST_CSS_RESETS = `:host, *, *::before, *::after {box-sizing: border-box;} `,\n//     context = {};\n//\n// export const provide = (namespace, attach) => context[namespace] = attach;\n//\n//\n//\n// const getShadowParent = element => {\n//     while (element.parentNode && (element = element.parentNode)) {\n//         if (element instanceof ShadowRoot) {\n//             return element;\n//         }\n//     }\n//     return document;\n// };\n//\n// /* lots of inspiration from superfine, atomico, stencil, and preact*/\n// export class Element extends HTMLElement {\n//\n//     context = context;\n//\n//     unsubs = [];\n//\n//     state = {};\n//\n//     constructor() {\n//         super();\n//         // the statically set fields from the class that extends this\n//         let {initAttrs, shadow, rootSheet, noRerender, tag} = this.constructor;\n//\n//         let root = !shadow ? this : this.attachShadow({mode: ['open', 'closed'].includes(shadow) ? shadow : 'open'});\n//\n//         this[PROPS] = {};\n//\n//         this.render = this.render.bind(this);\n//\n//         // store a pending promise to mounted.\n//         // Promise is resolved in connectedCallback when mount is called\n//         this.mounted = new Promise(mount => (this._mount = mount));\n//\n//         /*\n//          * adopts style sheets to the shadowRoot or the document\n//          * @param sheets {array|CSSStyleSheet}\n//          * @returns {string}\n//          */\n//         const adoptSheets = sheets => {\n//             let adopter = shadow ? root : getShadowParent(this);\n//\n//             let combinedCSSTextIfNotAdoptable = '';\n//\n//             sheets.forEach(customArrayOrSheet => {\n//                 if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE) {\n//                     // check if the style sheet was created with createStyleSheet()\n//                     let sheet = isArray(customArrayOrSheet) ? customArrayOrSheet[0] : customArrayOrSheet;\n//                     if (sheet && !([].concat(adopter.adoptedStyleSheets).includes(sheet))) {\n//                         adopter.adoptedStyleSheets = [...adopter.adoptedStyleSheets, sheet];\n//                     }\n//                 } else if (isArray(customArrayOrSheet) && customArrayOrSheet[1]) {\n//                     combinedCSSTextIfNotAdoptable = combinedCSSTextIfNotAdoptable + customArrayOrSheet[1]\n//                 }\n//             });\n//             return combinedCSSTextIfNotAdoptable\n//         };\n//\n//         let hasAdoptedExternalSheets = false, combinedCSSTextIfNotAdoptable = '';\n//         /**\n//          * optionally use constructable style sheets with fall backs if not supported\n//          * @param css {string} - css text\n//          * @param noResets {boolean} - exclude the default box-sizing reset on the :host\n//          * @param globalFallback {boolean} - if no constructableStylesheets then optionally allow a style tag in the head of the document instead of a style tag\n//          * @param useStyleTag {boolean} - use a style tag even if constructableStylesheets\n//          * @param styleSheets {array} - an array of style sheets made with createStyleSheet\n//          * @param children - child vNodes\n//          * @returns {*}\n//          */\n//         const CSS = ({css, noResets, globalFallback, useStyleTag, styleSheets}, children) => {\n//             if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE) adoptSheets([rootSheet]);\n//             // get the cssText from the props or the first child vNode.\n//             let cssText = css || isObj(children[0]) && children[0].name || '';\n//             // if using shadow then include the resets by default if noResets is not explicitly set to true.\n//             if (!noResets && shadow) cssText = DEFAULT_SHADOWROOT_HOST_CSS_RESETS + cssText;\n//\n//             // adopt the external styleSheets only once.\n//             if (!hasAdoptedExternalSheets && isArray(styleSheets)) {\n//                 combinedCSSTextIfNotAdoptable = adoptSheets(styleSheets);\n//                 hasAdoptedExternalSheets = true;\n//             }\n//             // if no constructableStylesheets and opting-in to a style tag in the head of the document\n//             // and the styles have not already been placed (checking globalStyleTagCache),\n//             // then set them only once\n//             if (!CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE && globalFallback && !globalStyleTagCache[tag]) {\n//                 globalStyleTagCache[tag] = true;\n//                 globalStyles(cssText + combinedCSSTextIfNotAdoptable);\n//                 return null;\n//             } else if (!CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE || useStyleTag) { // fallback to a style tag or opt-in\n//                 return <style>{cssText + combinedCSSTextIfNotAdoptable}</style>;\n//             } else if (rootSheet.cssRules.length === 0) { // apply the cssText\n//                 rootSheet.replaceSync(cssText);\n//                 return null\n//             }\n//             return null;\n//         };\n//\n//         let usingVHost, lastSelfHostPropsEmpty;\n//\n//         const Host = (selfProps, children) => {\n//             usingVHost = true; // let the renderers know that we are using a vHost node\n//             let kids = h(HOST_TYPE, {}, children);\n//             //can skip patching the host props during the first render if no props are provided\n//             if (!this.hasMounted && objectIsEmpty(selfProps)) return (lastSelfHostPropsEmpty = true, kids);\n//             if (lastSelfHostPropsEmpty && objectIsEmpty(selfProps)) return kids;\n//             lastSelfHostPropsEmpty = false;\n//             // convert the attributes from this element into props format\n//             let hostNodeProps = {}, i = 0, a = this.attributes;\n//             for (i = a.length; i--;) {\n//                 let attr = a[i].name;\n//                 hostNodeProps[attr === 'class' ? 'className' : attr] = a[i].value;\n//             }\n//             //apply host vnode props on 'this', merge in and potentially override individual properties that exist\n//             for (let key in selfProps) patchProperty(this, key, hostNodeProps[key], selfProps[key]);\n//             return kids;\n//         };\n//\n//         this.setState = nextState => {\n//             extend(this.state, isFunc(nextState) ? nextState(this.state) : nextState || {});\n//             return this.update();\n//         };\n//\n//         this.observeObi = obis =>\n//             [].concat(obis).forEach(obi =>\n//                 obi.$onChange && this.unsubs.push(obi.$onChange(this.update)));\n//\n//         const renderArgs = () => {\n//             // if watching the style property, convert the style string ('width:100%;') into an object ({width: '100%'})\n//             if (this._observesStyle) this[PROPS].style = CSSTextToObj(this.style.cssText);\n//             return [\n//                 extend({Host, CSS, host: this}, this[PROPS]),\n//                 this.state,\n//                 this.context\n//             ];\n//         };\n//\n//         let base, noRenderResults;\n//         const initialRenderer = () => {\n//             let next = renderArgs();\n//             this.willMount(...next);\n//             this.willRender(...next);\n//             let results = this.render(...next);\n//             if (results) {\n//                 let mountPoint = createElem(usingVHost ? 'template' : results.name);\n//                 appendChild(root, mountPoint);\n//                 base = patch(usingVHost && shadow ? root : mountPoint, results);\n//             } else noRenderResults = true;\n//\n//             let postInitial = () => {\n//                 this.unsubs.push(this.lifeCycle(...next)); // optionally return subscriptions to unsub on detach\n//                 // Removing this functionality during testing makes life easier.\n//                 this.didRender(...next);\n//                 this.didMount(...next);\n//                 this.hasMounted = true;\n//             };\n//             !TEST_ENV ? raf(postInitial) : postInitial();\n//         };\n//\n//         const subsequentRenderer = () => {\n//             let next = renderArgs();\n//             let shouldRerender = this.willRender(...next); //\n//             this.willUpdate(...next);\n//             if (this.shouldUpdate) shouldRerender = this.shouldUpdate(...next);\n//             // returning a falsy value other than undefined will prevent rerender\n//             if (noRerender || noRenderResults || (!shouldRerender && (shouldRerender !== undefined))) return;\n//             patch(usingVHost && shadow ? root : base, this.render(...next));\n//             this.didUpdate(...next);\n//             this.didRender(...next);\n//         };\n//\n//         this.update = () => {\n//             if (!this.processing) this.processing = this.mounted.then(_ => {\n//                 !this.hasMounted ? initialRenderer() : subsequentRenderer();\n//                 this.processing = false;\n//             });\n//             return this.processing;\n//         };\n//\n//         this.emit = (name, detail, from, options) => (from || this).dispatchEvent(\n//             new CustomEvent(name, extend({detail, bubbles: true, composed: true}, options || {}))\n//         );\n//\n//         let destroyed;\n//\n//         this.destroy = (dom) => {\n//             if (!destroyed) {\n//                 dom && removeHandlers(dom);\n//                 this.unsubs.forEach(fn => isFunc(fn) && fn());\n//                 destroyed = true;\n//             }\n//         };\n//\n//         let length = initAttrs.length;\n//         while (length--) initAttrs[length](this);\n//\n//         this.update();\n//     }\n//\n//     connectedCallback() {\n//         // connected callback may be called inadvertently, so check this.\n//         if (this.hasMounted) return;\n//         // if state is using an obi (mini observable object) then push the sub into unsubs\n//         this.state.$onChange && this.unsubs.push(this.state.$onChange(this.update));\n//         this.observe && this.observeObi(this.observe);\n//         // resolve the pending promise that was set to this.mounted.\n//         this._mount();\n//     }\n//\n//     disconnectedCallback() {\n//         // the component may inadvertently call this, so check if its connected before calling destroy.\n//         // can happen if the node is being moved ex:  parent.insertBefore(node, targetNode).\n//         if (!this.isConnected) {\n//             this.willUnmount();\n//             this.destroy();\n//         }\n//     }\n//\n//     attributeChangedCallback(attr, oldValue, newValue) {\n//         // if we are setting our own attribute that we are tracking, then ignore this update.\n//         if (this[IGNORE_ATTR] === attr || oldValue === newValue) return;\n//         // opt-in notify for styles\n//         if (attr === 'style' && this._observesStyle) this.update();\n//         // else convert kabob-case to CamelCase\n//         else this[attrToProp(attr)] = newValue;\n//     }\n//\n//     /*  -- a little recap on prototype --\n//         When a constructor (a.k.a. pseudo classical inheritance) function is built,\n//         the newly created objects inherit the prototype properties of the constructor function\n//         and that’s the critical feature of constructors. They (constructor functions)\n//         are built for the initialization of newly created objects.*/\n//\n//     /*  let the prototype know what attributes to observe\n//         called while constructing the class / creating the prototype. */\n//     static get observedAttributes() {\n//         let {\n//             propTypes, // get the statically set propTypes.\n//             prototype // prototype - the soon to be - newly instantiated class.\n//         } = this; // 'this' will references the constructor when used inside static methods.\n//         this.initAttrs = [];\n//         if (!propTypes) return [];\n//         /* inspired by atomico  */\n//         let observedAttr = Object.keys(propTypes).map(prop => {\n//             let attr = propToAttr(prop);// convert the camelCase to kabob-case.\n//             let schema = propTypes[prop].name ? {type: propTypes[prop]} : propTypes[prop];\n//             //dynamically build the setters and getters for the prototype during the construction phase.\n//             if (!(prop in prototype)) { // ignores properties that exist, like style and className\n//                 // def = (obj, prop, handlers) => Object.defineProperty(obj, prop, handlers),\n//                 def(prototype, prop, {\n//                     // keep an internal reference to the observed properties on this.props.\n//                     // provide an access getter.\n//                     get() {// <--- since this is not a lexical scope function aka () => { };\n//                         // then 'this' (in this scope) will reference the prototype.\n//                         return this[PROPS][prop]\n//                     },\n//                     // react to updates when the value is set on the instance.\n//                     set(nextValue) {\n//                         // format the incoming value into the type that it is defined in on the propTypes object\n//                         // ex: if its an Object, then JSON.parse the value\n//                         let {value, error} = formatType(nextValue, schema.type);\n//                         if (error && value != null) console.error(`[${prop}] must be type [${schema.type.name}]`);\n//                         // if the value is the same, then dip out.\n//                         if (value === this[PROPS][prop]) return;\n//                         // if the value is meant to be reflected\n//                         // then set it as an attribute\n//                         if (schema.reflect) { // several sequential updates are deferred/debounced with the pending promise\n//                             this.mounted.then(() => { // and are only set after the component has finished constructing.\n//                                 // setting IGNORE_ATTR ignores attribute during attributeChangedCallback\n//                                 // because we handle our own update.\n//                                 this[IGNORE_ATTR] = attr;\n//                                 //either set or remove the attribute.\n//                                 updateAttribute(\n//                                     this,\n//                                     attr,\n//                                     schema.type === Boolean && !value\n//                                         ? null\n//                                         : value\n//                                     // (!schema.reflect && schema.type === Boolean && value === true) ? '' : value\n//                                 );\n//                                 this[IGNORE_ATTR] = false;\n//                             });\n//                         }\n//                         this[PROPS][prop] = value;\n//                         this.update();\n//                     }\n//                 });\n//             }\n//             // prime the default attributes if the propTypes schema has default value.\n//             // will initialize in the constructor of the prototype.\n//             schema.value && this.initAttrs.push(self => (self[prop] = schema.value));\n//             return attr;\n//         });\n//         // let the prototype know to listen for style changes here since ('style' in prototype) is true\n//         // and since we want more control over how the style is updated ex: {...userStyles, ...ourStyles}\n//         this.prototype._observesStyle = observedAttr.includes('style');\n//         return observedAttr;\n//     };\n//\n//     willMount() { // called once before render\n//     }\n//\n//     willRender() { // called before every render, optionally return false to prevent any further re-rendering\n//         // will still render one time\n//         // return false; // but no more rendering!\n//     }\n//\n//     render() {\n//     }\n//\n//     didRender() { // called after every render\n//     }\n//\n//     willUpdate() { // called before every render besides the first\n//     }\n//\n//     didUpdate() { // called after every render besides the first\n//     }\n//\n//     didMount() { // called once after first render\n//     }\n//\n//     lifeCycle() { // same as didMount but optionally return a callback to be called during willUnmount\n//         // return ()=> subscription.unsubscribe();\n//     }\n//\n//     willUnmount() {\n//     }\n//\n// }\n//\n//\n// export const x = (tag, component, config) => {\n//\n//     config = config || {};\n//\n//     let rootSheet,\n//         isComponent = component.prototype instanceof Element;\n//\n//     if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE) rootSheet = new CSSStyleSheet();\n//\n//     if (isComponent) {\n//         component.rootSheet = rootSheet;\n//         component.tag = tag;\n//     }\n//\n//     customElements.define(tag,\n//         isComponent ? component : class extends Element {\n//             static rootSheet = rootSheet;\n//             static tag = tag;\n//             static propTypes = config.propTypes;\n//             static shadow = config.shadow;\n//             static noRerender = config.noRerender;\n//             render = component\n//         }\n//     );\n//\n//     return (props, children) => h(tag, props, children);\n// };\n//\n//\n"],"names":["d","document","CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE","headStyleTag","mount","style","createElement","appendChild","createTextNode","head","css","formatType","value","type","String","Boolean","includes","Number","Object","Array","JSON","parse","toString","call","name","error","isNaN","isCustomElement","el","isAttr","getAttribute","localName","updateAttribute","node","attr","removeAttribute","setAttribute","isObj","isArray","stringify","propToAttr","prop","replace","toLowerCase","attrToProp","all","letter","toUpperCase","createStyleSheet","cssText","async","sheet","CSSStyleSheet","getShadowParent","elmnt","parentNode","ShadowRoot","adoptSheets","styleSheets","getCombined","element","adopter","shadowRoot","combinedCSSTextIfNotAdoptable","adopt","customArrayOrSheet","concat","adoptedStyleSheets","forEach","constructableStyleCache","constructableStyleTagFallbackCache","DEFAULT_SHADOWROOT_HOST_CSS_RESETS","createStyleTag","textNode","update","replaceWith","adoptStyles","tag","cssString","useStyleTag","constructable","cloneNode","select","host","selector","querySelector","createRefs","refs","reduce","acc","curr","createRefsFromIDs","tagTemplateCache","appendTemplate","templateStr","temp","innerHTML","content","UpdatableTemplate","html","getElementProps","i","hostNodeProps","a","attributes","length","makeProxyObj","fallBackGetter","Proxy","get","target","key","proxyAttrs","updateAttr","set","PromiseBatch","resolve","processing","promise","Promise","updater","fn","args","console","log","then","_","ProxyProps","_props","mounted","def","props","updateFn","reflect","keys","val","reflectPropsToAttrs","prototype","_val","isFunc","self","emit","from","event","detail","opts","dispatchEvent","CustomEvent","bubbles","composed","IGNORE_ATTR","Symbol","reactiveProps","construct","initAttrs","constructor","prevProps","_mount","hasMounted","didUpdate","didMount","observedAttrs","existingAttrs","propTypes","map","schema","nextValue","this","push","connect","attrChange","oldValue","newValue","createReactiveProps","ReactiveElement","HTMLElement","observedAttributes","super","connectedCallback","attributeChangedCallback","old","_new","TEST_ENV","createBase","h","render","setProperty","globalStyleTagCache","context","globalStyles","Element","unsubs","state","observe","shadow","rootSheet","noRerender","root","attachShadow","mode","bind","combinedCSSText","cssOncePerRenderVerify","renderStyle","CSS","noResets","globalFallback","children","cssRules","replaceSync","lastSelfHostPropsEmpty","Host","selfProps","objectIsEmpty","setState","nextState","observeObi","obis","obi","$onChange","renderArgs","_observesStyle","CSSTextToObj","extend","initialRenderer","next","willMount","willRender","setTimeout","lifeCycle","didRender","subsequentRenderer","shouldRerender","willUpdate","shouldUpdate","options","destroy","willUnmount","disconnectedCallback","isConnected","observedAttr","x","config","isElement","customElements","define","X","XShadow","provide","namespace","attach"],"mappings":"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"}