import{obi as t}from"@iosio/obi";import{eventListener as e,isObj as s}from"@iosio/util";import{h as o,render as n}from"@iosio/vdom";export{Fragment,createNode,h,mount,render}from"@iosio/vdom";class r extends HTMLElement{constructor(r){super(r),this[p]=()=>[this.props,this.prevProps,this.changedProps],this.emit=(t,e,s={},o=this)=>o.dispatchEvent(new CustomEvent(t,{detail:e,bubbles:!0,composed:!0,...s})),this.eventListener=(t,s,o,n)=>this.unsubs.push(e(t,s,o,n)),this.renderer=()=>{let t=this.render(this.props,this.state);if(t){if(this.fallbackCssString){let e=o("style",{dangerouslySetInnerHTML:{__html:this.fallbackCssString||""}});t=Array.isArray(t)?(t.unshift(e),t):[e,t]}n(this.shadowRoot||this,t)}},this.onStateChange=()=>this.update();const{shadow:i,styles:h,template:l,proxyRefs:d}=this.constructor;i&&this.attachShadow({mode:"open"}),s(h)&&h.global&&!N.get(this.constructor)&&(x()(h.global),N.set(this.constructor,!0));let u=!0,m=t=>{let{options:e={},css:o=""}=s(t)?t:{css:t};this.fallbackCssString=v(this,o,{getStringOnFallback:!!this.render,...e})},b=()=>{h&&m(h),l&&L(this,l)};Object.assign(this,{unsubs:[],refs:d?P(d)(this):{},props:{},prevProps:{},changedProps:[],mounted:new Promise(t=>this.mount=t),initialized:new Promise(t=>this.init=t),update:()=>(this.processing||(this.processing=this.mounted.then(t=>{if(this.render&&this.renderer(),u){this.unmount=this.didMount(...this[p]())||c;const t=this.propLogic&&this.propLogic(!0);t&&Object.keys(this.props).forEach(e=>{t[e]&&t[e](this.props[e],this.refs)})}else{const t=this.shouldUpdate(...this[p]());if(t||void 0===t){this.didUpdate(...this[p]());const t=this.propLogic&&this.propLogic();t&&this.changedProps.forEach(e=>t[e]&&t[e](this.props[e],this.refs))}}u=!1,this.changedProps=[],this.processing=!1})),this.processing)}),i&&b(),this.initialized.then(()=>{!i&&b(),this.state&&this.unsubs.push((this.state=t(this.state)).$onChange((t,e)=>R(()=>this.onStateChange(t,e)))),this.beforeInitialUpdate(...this[p]()),this.mount()});let g=this.constructor[a],f=g.length;for(;f--;)g[f](this);this.update()}connectedCallback(){this[l]||(this[l]=!0,this.init())}attributeChangedCallback(t,e,s){this[i]!==t&&e!==s&&(this[u(t)]=s)}static get observedAttributes(){let{prototype:t,propTypes:e}=this;return this[a]=[],e?Object.keys(e).map(s=>{let o=d(s),n="any"===e[s]||e[s].name?{type:e[s]}:e[s];return s in t||Object.defineProperty(t,s,{get(){return this.props[s]},set(t){let{value:e,error:r}=b(t,n.type);r&&null!=e&&console.error(`[${s}] must be type [${n.type.name}]`),e!==this.props[s]&&(this.changedProps.push(s),n.reflect&&this.mounted.then(()=>{this[i]=o,m(this,o,n.type!==Boolean||e?e:null),this[i]=!1}),this.prevProps[s]=this.props[s],this.props[s]=e,this.update())}}),n.value&&this[a].push(t=>t[s]=n.value),o}):[]}disconnectedCallback(){let{isConnected:t,unmount:e,willUnmount:s,unsubs:o}=this;if(!t){"function"==typeof e&&e(),s();for(let t=o.length;t--;)o[t]&&o[t]()}}didUpdate(){}didMount(){}beforeInitialUpdate(){}shouldUpdate(){}willUnmount(){}}const i=Symbol(),a=Symbol(),l=Symbol(),p=Symbol();let c=()=>{};const d=t=>t.replace(/([A-Z])/g,"-$1").toLowerCase(),u=t=>t.replace(/-(\w)/g,(t,e)=>e.toUpperCase()),m=(t,e,s)=>{null===s||!1===s||"null"===s||"false"===s?t.removeAttribute(e):t.setAttribute(e,"object"==typeof s?JSON.stringify(s):s)},b=(t,e)=>"any"===e?{value:t,error:!1}:((e=e||String)==Boolean?t=[!0,1,"","1","true"].includes(t):"string"==typeof t&&(t=e==Number?Number(t):e==Object||e==Array?JSON.parse(t):t),{}.toString.call(t)==`[object ${e.name}]`?{value:t,error:e==Number&&Number.isNaN(t)}:{value:t,error:!0}),g=t=>{let e=document.createElement("style");return e.appendChild(document.createTextNode(t)),{element:e,update:t=>e.textContent=t}},f=t=>{for(;t.parentNode&&(t=t.parentNode);)if(t instanceof ShadowRoot)return t;return document},y="adoptedStyleSheets"in document,S=":host, *, *::before, *::after {box-sizing: border-box;} ",C=new Map,w=new Map,v=(t,e,s={})=>{const{async:o,getStringOnFallback:n,useStyleTag:r,noDefaultResets:i}=s;e=(t.shadowRoot&&!i?":host, *, *::before, *::after {box-sizing: border-box;} ":"")+(e||s.cssString||"");const h=t.constructor.tag||t.constructor;if(y&&!r){let s=t.shadowRoot||f(t),n=C.get(h);n||(n=new CSSStyleSheet,n[o?"replace":"replaceSync"](e),C.set(h,n)),[].concat(s.adoptedStyleSheets).includes(n)||(s.adoptedStyleSheets=[...s.adoptedStyleSheets,n])}else{if(n)return e;let s=w.get(h);s||(s=g(e).element,w.set(h,s)),(t.shadowRoot||t).appendChild(s.cloneNode(!0))}},N=new Map,x=(t,e)=>{let s=document.createElement("style");return t&&(s.id=t),s.appendChild(document.createTextNode("")),(e||document.head).appendChild(s),t=>(s.appendChild(document.createTextNode(t)),s)},P=t=>e=>{let{selector:o=(t=>`#${t}`),selectMethod:n="querySelector"}=s(t)?t:{},r={},i=e.shadowRoot||e;return new Proxy({},{get:(t,e)=>"refreshRefsCache"===e?()=>r={}:(r[e]||(r[e]=i[n](o(e))),r[e])})},M=new Map,L=(t,e)=>{if(!t||!e)return;let s=t.shadowRoot||t,o=t.constructor,n=M.get(o);n||(n=document.createElement("template"),n.innerHTML=e,M.set(o,n)),s.appendChild(n.content.cloneNode(!0))};let k=new Promise(t=>t());const R=t=>k.then(t),T=(t,e,s)=>t[s?"setAttribute":"removeAttribute"](e,""),A=t=>{let e=document.createElement("template");return e.innerHTML=t,e},E=(t,e)=>{let s=A(e);t.innerHTML="",t.appendChild(s.content.cloneNode(!0))},O=()=>{const t={};return(e,s)=>(t[e]||(t[e]=A(s)),t[e].content.cloneNode(!0))};export{y as CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE,S as DEFAULT_SHADOWROOT_HOST_CSS_RESETS,r as Elemental,O as TemplateMapFactory,v as adoptStyles,L as appendTemplate,u as attrToProp,T as booleanAttr,g as createStyleTag,A as createTemplate,R as defer,b as formatType,f as getShadowParent,x as headStyleTag,d as propToAttr,P as refs,E as templateToHost,m as updateAttribute};
//# sourceMappingURL=index.js.map
