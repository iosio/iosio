{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["// import {def, extend, isFunc, isObj, Subie, arrayIncludesItemFromArray} from \"@iosio/util\";\n//\n//\n// export const select = (obi, selections = []) => ({\n//     $onChange: (callback) => {\n//\n//         const {sub, notify} = Subie(),\n//\n//             mainUnsub = obi.$onAnyChange((data, paths = []) =>\n//                 arrayIncludesItemFromArray(selections, paths) && notify(data, paths)\n//             ),\n//             unsub = sub(callback);\n//\n//         return () => (mainUnsub(), unsub());\n//     }\n// });\n//\n//\n// let non_enumerables = ['$obi', '$batching', '$onChange', '$getState', '$merge', '$path', '$select'];\n//\n// export const obi = suspect => {\n//     let {sub: base_sub, notify: base_notify} = Subie();\n//     let notifyingPaths = [];\n//     const obiOuter = (_suspect, lastPath = '') => {\n//         const {sub, notify} = Subie();\n//         let makeObi = (obj, _lastPath = '') => {\n//             if (obj.$obi) return obj;\n//             def(obj, '$obi', {enumerable: false, value: true});\n//             def(obj, '$batching', {enumerable: false, value: {active: false}});\n//             def(obj, '$onChange', {\n//                 enumerable: false,\n//                 value: (callback) => sub(callback)\n//             });\n//             def(obj, '$onAnyChange', {\n//                 enumerable: false,\n//                 value: (callback) => base_sub(callback)\n//             });\n//             def(obj, '$getState', {\n//                 enumerable: false,\n//                 value: () => Object.keys(obj).reduce((acc, curr) =>\n//                     !isFunc(obj[curr]) ? (acc[curr] = (isObj(obj[curr]) && obj[curr].$obi)\n//                         ? obj[curr].$getState() : obj[curr], acc) : acc, {})\n//             });\n//             def(obj, '$merge', {\n//                 enumerable: false,\n//                 value: (update, ignoreUpdate) => {\n//                     suspect.$batching.active = true;\n//                     isFunc(update) ? update(_suspect) : extend(_suspect, update);\n//                     suspect.$batching.active = false;\n//                     if (!ignoreUpdate) {\n//                         notify(_suspect, notifyingPaths);\n//                         base_notify(suspect, notifyingPaths);\n//                     }\n//                     notifyingPaths = [];\n//                 }\n//             });\n//             def(obj, '$select', {\n//                 enumerable: false,\n//                 value: (selections = []) => extend({}, {\n//                     ...obj,\n//                     ...select(obj, selections)\n//                 })\n//             });\n//             for (let key in obj) {\n//                 let internal = obj[key];\n//                 if (isFunc(internal) || non_enumerables.includes(key)) continue;\n//                 let path = _lastPath + (_lastPath ? '.' : '') + key;\n//                 if (isObj(internal)) obiOuter(obj[key], path);\n//                 def(obj, key, {\n//                     enumerable: true,\n//                     get: () => internal,\n//                     set(value) {\n//                         if (value === internal) return;\n//                         if (isObj(value) && isObj(internal) && obj[key].$merge) {\n//                             obj[key].$merge(value);\n//                         } else {\n//                             internal = value;\n//                             notifyingPaths.push(path);\n//                             if (!suspect.$batching.active) {\n//                                 notify(_suspect, [path]);\n//                                 base_notify(suspect, [path]);\n//                                 notifyingPaths = [];\n//                             }\n//                         }\n//                     },\n//                 });\n//             }\n//             return obj\n//         };\n//         return makeObi(_suspect, lastPath);\n//     };\n//     return obiOuter(suspect)\n// };\nexport const obi =\n    (suspect, _parent = suspect, _lastPath = '', [base_sub, base_notify] = Subie(), notifyingPaths = []) => {\n        if (suspect.$obi) return suspect;\n        const [sub, notify] = Subie(), _obi = {\n            $obi: true,\n            $batch: {_: 0},\n            $onChange: cb => sub(cb),\n            $onAnyChange: cb => base_sub(cb),\n            $getState: () => Object.keys(suspect).reduce((acc, curr) =>\n                !isFunc(suspect[curr]) ? (acc[curr] = (isObj(suspect[curr]) && suspect[curr].$obi)\n                    ? suspect[curr].$getState() : suspect[curr], acc) : acc, {}),\n            $merge: (update, ignoreUpdate) => {\n                _parent.$batch._ = true;\n                isFunc(update) ? update(suspect) : Object.keys(update).map(k => suspect[k] = update[k]);\n                _parent.$batch._ = false;\n                if (!ignoreUpdate) notify(suspect, notifyingPaths), base_notify(_parent, notifyingPaths);\n                notifyingPaths = [];\n            },\n            $select: (selections = []) => ({\n                ...suspect, $onChange: (callback, [sub, notify] = Subie(), mainUnsub, unsub) => (\n                    mainUnsub = _parent.$onAnyChange((data, paths = []) =>\n                        selections.some(val => paths.includes(val)) && notify(data, paths)\n                    ), unsub = sub(callback), () => (mainUnsub(), unsub())\n                )\n            })\n        };\n        for (let key in suspect) {\n            let internal = suspect[key], path = _lastPath + (_lastPath ? '.' : '') + key;\n            if (isObj(internal)) obi(suspect[key], _parent, path, [base_sub, base_notify], notifyingPaths);\n            def(suspect, key, {\n                enumerable: true,\n                get: () => internal,\n                set(value) {\n                    if (value === internal) return;\n                    isObj(value) && isObj(internal) && suspect[key].$merge ?\n                        suspect[key].$merge(value) : (\n                            (internal = value), notifyingPaths.push(path),\n                            !_parent.$batch._ && (base_notify(_parent, [path]),\n                                notify(suspect, [path]), (notifyingPaths = []))\n                        )\n                }\n            });\n        }\n        for (let k in _obi) def(suspect, k, {enumerable: false, value: _obi[k]});\n        return suspect\n    };\nconst isObj = thing => typeof thing === 'object' && !Array.isArray(thing),\n    isFunc = thing => typeof thing === 'function',\n    Subie = (subs = [], _unsub = it => subs.splice(subs.indexOf(it) >>> 0, 1)) => [\n        it => ((subs.push(it), () => _unsub(it))), (...data) => subs.slice().map(f => f(...data)), _unsub\n    ], def = (s, k, o) => Object.defineProperty(s, k, o);"],"names":["obi","suspect","_parent","_lastPath","base_sub","base_notify","Subie","notifyingPaths","$obi","sub","notify","_obi","$batch","_","$onChange","cb","$onAnyChange","$getState","Object","keys","reduce","acc","curr","isFunc","isObj","$merge","update","ignoreUpdate","map","k","$select","selections","callback","mainUnsub","unsub","data","paths","some","val","includes","key","internal","path","def","enumerable","get","set","value","push","thing","Array","isArray","subs","_unsub","it","splice","indexOf","slice","f","s","o","defineProperty"],"mappings":"AA6FaA,MAAAA,EACT,CAACC,EAASC,EAAUD,EAASE,EAAY,IAAKC,EAAUC,GAAeC,IAASC,EAAiB,MAC7F,GAAIN,EAAQO,KAAM,OAAOP,EACzB,MAAOQ,EAAKC,GAAUJ,IAASK,EAAO,CAClCH,MAAM,EACNI,OAAQ,CAACC,EAAG,GACZC,UAAWC,GAAMN,EAAIM,GACrBC,aAAcD,GAAMX,EAASW,GAC7BE,UAAW,IAAMC,OAAOC,KAAKlB,GAASmB,OAAO,CAACC,EAAKC,IAC9CC,EAAOtB,EAAQqB,IACwCD,GAD9BA,EAAIC,GAASE,EAAMvB,EAAQqB,KAAUrB,EAAQqB,GAAMd,KACvEP,EAAQqB,GAAML,YAAchB,EAAQqB,GAAOD,GAAY,IACjEI,OAAQ,CAACC,EAAQC,KACbzB,EAAQU,OAAOC,GAAI,EACnBU,EAAOG,GAAUA,EAAOzB,GAAWiB,OAAOC,KAAKO,GAAQE,IAAIC,GAAK5B,EAAQ4B,GAAKH,EAAOG,IACpF3B,EAAQU,OAAOC,GAAI,EACdc,IAAcjB,EAAOT,EAASM,GAAiBF,EAAYH,EAASK,IACzEA,EAAiB,IAErBuB,QAAS,CAACC,EAAa,UAChB9B,EAASa,UAAW,CAACkB,GAAWvB,EAAKC,GAAUJ,IAAS2B,EAAWC,KAClED,EAAY/B,EAAQc,aAAa,CAACmB,EAAMC,EAAQ,KAC5CL,EAAWM,KAAKC,GAAOF,EAAMG,SAASD,KAAS5B,EAAOyB,EAAMC,IAC7DF,EAAQzB,EAAIuB,GAAW,KAAOC,IAAaC,SAI1D,IAAK,IAAIM,KAAOvC,EAAS,CACrB,IAAIwC,EAAWxC,EAAQuC,GAAME,EAAOvC,GAAaA,EAAY,IAAM,IAAMqC,EACrEhB,EAAMiB,IAAWzC,EAAIC,EAAQuC,GAAMtC,EAASwC,EAAM,CAACtC,EAAUC,GAAcE,GAC/EoC,EAAI1C,EAASuC,EAAK,CACdI,YAAY,EACZC,IAAK,IAAMJ,EACXK,IAAIC,GACIA,IAAUN,IACdjB,EAAMuB,IAAUvB,EAAMiB,IAAaxC,EAAQuC,GAAKf,OAC5CxB,EAAQuC,GAAKf,OAAOsB,IACfN,EAAWM,EAAQxC,EAAeyC,KAAKN,IACvCxC,EAAQU,OAAOC,IAAMR,EAAYH,EAAS,CAACwC,IACxChC,EAAOT,EAAS,CAACyC,IAASnC,EAAiB,SAKnE,IAAK,IAAIsB,KAAKlB,EAAMgC,EAAI1C,EAAS4B,EAAG,CAACe,YAAY,EAAOG,MAAOpC,EAAKkB,KACpE,OAAO5B,GAETuB,EAAQyB,GAA0B,iBAAVA,IAAuBC,MAAMC,QAAQF,GAC/D1B,EAAS0B,GAA0B,mBAAVA,EACzB3C,EAAQ,CAAC8C,EAAO,GAAIC,EAASC,CAAAA,GAAMF,EAAKG,OAAOH,EAAKI,QAAQF,KAAQ,EAAG,MAAO,CAC1EA,IAAQF,EAAKJ,KAAKM,GAAK,IAAMD,EAAOC,IAAO,IAAInB,IAASiB,EAAKK,QAAQ7B,IAAI8B,GAAKA,KAAKvB,IAAQkB,GAC5FV,EAAM,CAACgB,EAAG9B,EAAG+B,IAAM1C,OAAO2C,eAAeF,EAAG9B,EAAG+B"}