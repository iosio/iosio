import{isObj as t,isArray as e,isFunc as s,def as i,extend as r,objectIsEmpty as n,CSSTextToObj as o}from"@iosio/util";const h=document,l="adoptedStyleSheets"in document,a=t=>{let e=h.createElement("style");return e.appendChild(h.createTextNode("")),(t||h.head).appendChild(e),t=>(e.appendChild(h.createTextNode(t)),e)},d={},u=(t,e)=>{let s=!1;return l&&(s=new CSSStyleSheet)[e?"replace":"replaceSync"](t),[s,t]},c=(t,e)=>{e=e||String;try{if(e==Boolean?t=[!0,1,"","1","true"].includes(t):"string"==typeof t&&(t=e==Number?Number(t):e==Object||e==Array?JSON.parse(t):t),{}.toString.call(t)==`[object ${e.name}]`)return{value:t,error:e==Number&&Number.isNaN(t)}}catch(t){}return{value:t,error:!0}},p=(t,e)=>!(!t.getAttribute||!t.localName)&&(e=t.getAttribute("is"),t.localName.includes("-")||e&&e.includes("-")),b=(s,i,r)=>{null===r||!1===r?s.removeAttribute(i):s.setAttribute(i,p(s)&&(t(r)||e(r))?JSON.stringify(r):r)},m=t=>t.replace(/([A-Z])/g,"-$1").toLowerCase(),y=t=>t.replace(/-(\w)/g,(t,e)=>e.toUpperCase()),S=!1,g=({h:t,render:h,setProperty:u})=>{let p="props",S=Symbol(),g=":host, *, *::before, *::after {box-sizing: border-box;} ",f={};const w=t=>{for(;t.parentNode&&(t=t.parentNode);)if(t instanceof ShadowRoot)return t;return document},v=a();class C extends HTMLElement{constructor(){super(),this.context=f,this.unsubs=[],this.state={},this.observe=null;let{initAttrs:i,shadow:a,rootSheet:c,noRerender:b,tag:m}=this.constructor,y=a?this.attachShadow({mode:!0===a?"open":a}):this;this[p]={},this.render=this.render.bind(this),this.mounted=new Promise(t=>this._mount=t);const S=(t,s)=>{let i=a?y:w(this),r="",n=l&&!s?t=>{let s=e(t)?t[0]:t;s&&![].concat(i.adoptedStyleSheets).includes(s)&&(i.adoptedStyleSheets=[...i.adoptedStyleSheets,s])}:t=>{e(t)&&t[1]&&(r+=t[1])};return[].concat(t).forEach(n),r};let C="",x=0,N=!1;const R=({css:e,noResets:s,globalFallback:i,useStyleTag:r,styleSheets:n,children:o})=>{if(x>0)return null;if(x++,!1!==N)return N;let h=e||o||"";return!s&&a&&(h=g+h),l&&!r?(S(c),0===c.cssRules.length&&c.replaceSync(h),n&&S(n),N=null):(C=h+S(c,!0)+(n?S(n,!0):""),i&&!d[m]?(d[m]=!0,v(C),N=null):N=t("style",{},C)),N};let E;const A=({children:t,...e})=>{if(!this.hasMounted&&n(e))return E=!0,t;if(E&&n(e))return t;E=!1;let s,i={},r=this.attributes;for(s=r.length;s--;)i[r[s].name]=r[s].value;for(let t in e)u(this,t,e[t],i[t],!1);return t};this.setState=t=>(this.state={...this.state,...s(t)?t(this.state):t||{}},this.update()),this.observeObi=t=>[].concat(t).forEach(t=>t.$onChange&&this.unsubs.push(t.$onChange(this.update)));const M=()=>(this._observesStyle&&(this[p].style=o(this.style.cssText)),[r({Host:A,CSS:R,host:this},this[p]),this.state,this.context]),T=()=>{let t=M();this.willMount(...t),this.willRender(...t),h(this.render(...t),y),x=0,this.hasMounted=!0,setTimeout(()=>{this.unsubs.push(this.lifeCycle(...t)),this.didRender(...t),this.didMount(...t)})},U=()=>{let t=M(),e=this.willRender(...t);this.willUpdate(...t),this.shouldUpdate&&(e=this.shouldUpdate(...t)),b||!e&&void 0!==e||(h(this.render(...t),y),x=0,this.didUpdate(...t),this.didRender(...t))};this.update=()=>(this.processing||(this.processing=this.mounted.then(t=>{this.hasMounted?U():T(),this.processing=!1})),this.processing),this.emit=(t,e,s,i)=>(s||this).dispatchEvent(new CustomEvent(t,{detail:e,bubbles:!0,composed:!0,...i})),this.destroy=()=>{this.willUnmount(),h(null,y),this.unsubs.forEach(t=>s(t)&&t())};let O=i.length;for(;O--;)i[O](this);this.update()}connectedCallback(){this.hasMounted||(this.observe&&this.observeObi(this.observe),this._mount())}disconnectedCallback(){this.isConnected||this.destroy()}attributeChangedCallback(t,e,s){this[S]!==t&&e!==s&&("style"===t&&this._observesStyle?this.update():this[y(t)]=s)}static get observedAttributes(){let{propTypes:t,prototype:e}=this;if(this.initAttrs=[],!t)return[];let s=Object.keys(t).map(s=>{let r=m(s),n=t[s].name?{type:t[s]}:t[s];return s in e||i(e,s,{get(){return this[p][s]},set(t){let{value:e,error:i}=c(t,n.type);i&&null!=e&&console.error(`[${s}] must be type [${n.type.name}]`),e!==this[p][s]&&(n.reflect&&this.mounted.then(()=>{this[S]=r,b(this,r,n.type!==Boolean||e?e:null),this[S]=!1}),this[p][s]=e,this.update())}}),n.value&&this.initAttrs.push(t=>t[s]=n.value),r});return this.prototype._observesStyle=s.includes("style"),s}willMount(){}willRender(){}render(){}didRender(){}willUpdate(){}didUpdate(){}didMount(){}lifeCycle(){}willUnmount(){}}const x=(e,s,i={})=>{var r,n;let o,h=s.prototype instanceof C;return l&&(o=new CSSStyleSheet),h&&(s.rootSheet=o,s.tag=e),customElements.define(e,h?s:(n=r=class extends C{constructor(...t){super(...t),this.render=s}},r.rootSheet=o,r.tag=e,r.propTypes=i.propTypes,r.shadow=i.shadow,r.noRerender=i.noRerender,n)),s=>t(e,s)};let N,R,E=()=>{};return customElements.get("x-x")||customElements.get("x-shadow")||(N=x("x-x",E),R=x("x-shadow",E,{shadow:!0})),{x:x,X:N,XShadow:R,Element:C,provide:(t,e)=>f[t]=e}};export{l as CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE,S as TEST_ENV,y as attrToProp,g as createBase,u as createStyleSheet,h as d,c as formatType,d as globalStyleTagCache,a as headStyleTag,p as isCustomElement,m as propToAttr,b as updateAttribute};
