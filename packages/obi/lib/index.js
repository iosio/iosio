import{Subie as e,arrayIncludesItemFromArray as t,def as n,isFunc as a,isObj as u,extend as r}from"@iosio/util";const i=(n,a=[])=>({$onChange:u=>{const{sub:r,notify:i}=e(),l=n.$onAnyChange((e,n=[])=>t(a,n)&&i(e,n)),o=r(u);return()=>(l(),o())}});let l=["$obi","$batching","$onChange","$getState","$merge","$path","$select"];const o=t=>{let{sub:o,notify:$}=e(),b=[];const c=(g,s="")=>{const{sub:m,notify:h}=e();return((e,s="")=>{if(e.$obi)return e;n(e,"$obi",{enumerable:!1,value:!0}),n(e,"$batching",{enumerable:!1,value:{active:!1}}),n(e,"$onChange",{enumerable:!1,value:e=>m(e)}),n(e,"$onAnyChange",{enumerable:!1,value:e=>o(e)}),n(e,"$getState",{enumerable:!1,value:()=>Object.keys(e).reduce((t,n)=>a(e[n])?t:(t[n]=u(e[n])&&e[n].$obi?e[n].$getState():e[n],t),{})}),n(e,"$merge",{enumerable:!1,value:(e,n)=>{t.$batching.active=!0,a(e)?e(g):r(g,e),t.$batching.active=!1,n||(h(g,b),$(t,b)),b=[]}}),n(e,"$select",{enumerable:!1,value:(t=[])=>r({},{...e,...i(e,t)})});for(let r in e){let i=e[r];if(a(i)||l.includes(r))continue;let o=s+(s?".":"")+r;u(i)&&c(e[r],o),n(e,r,{enumerable:!0,get:()=>i,set(n){n!==i&&(u(n)&&u(i)&&e[r].$merge?e[r].$merge(n):(i=n,b.push(o),t.$batching.active||(h(g,[o]),$(t,[o]),b=[])))}})}return e})(g,s)};return c(t)};export{o as obi,i as select};
//# sourceMappingURL=index.js.map
